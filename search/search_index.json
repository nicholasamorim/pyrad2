{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyrad2","text":"<p>pyrad2 is an implementation of a RADIUS client/server as described in RFC2865. It takes care of all the details like building RADIUS packets, sending them and decoding responses.</p> <p>This port only supports Python 3.12+ and includes type checking along with increased test coverage. PRs are very welcome. For more information on what has changed, see our releases page.</p> <p>See the Getting Started guide for a tutorial on how to get started.</p>"},{"location":"compatibility/","title":"Pyrad Compatibility","text":"<p>In so far, there is near full-compatibility with pyrad and you can just replace your imports with <code>pyrad2</code>.</p>"},{"location":"compatibility/#list-of-breaking-changes","title":"List of breaking changes","text":"<ul> <li>Removed twisted support.</li> </ul>"},{"location":"getting_started/","title":"Getting started","text":"<p>Note</p> <p>This guide is a work in progress.</p> <ul> <li>How does pyrad2 work<ul> <li>RADIUS Concepts<ul> <li>Dictionary</li> </ul> </li> </ul> </li> <li>RADIUS Server<ul> <li>Handling packets</li> <li>Replying</li> </ul> </li> <li>RADIUS Client<ul> <li>Sending an authentication packet</li> </ul> </li> <li>Setting attributes</li> </ul> Install with pip<pre><code>$ pip install pyrad2\n</code></pre> Install with uv<pre><code>$ uv add pyrad2\n</code></pre>"},{"location":"getting_started/#how-does-pyrad2-work","title":"How does pyrad2 work","text":"<p>pyrad2 allows you to build servers and clients for the RADIUS protocol.</p> <p>It is not meant to be a standalone implementation like FreeRADIUS, but rather as a tool to allow you to build your own server and client.</p>"},{"location":"getting_started/#radius-concepts","title":"RADIUS Concepts","text":""},{"location":"getting_started/#dictionary","title":"Dictionary","text":"<p>For the purpose of using pyrad2, the most important concept is the Dictionary. The dictionary is an actual file on the filesystem.</p> <p>Note</p> <p>Dictionary files are textfiles with one command per line.</p> <p>RADIUS uses dictionaries to define the attributes that can be used in packets. The Dictionary class stores the attribute definitions from one or more dictionary files and allows Server/Client to understand what an attribute code means.</p> <p>Here's an example of how it looks:</p> <pre><code>ATTRIBUTE   User-Name           1   string\nATTRIBUTE   User-Password       2   string\nATTRIBUTE   CHAP-Password       3   octets\n</code></pre> <p>You can find a reference dictionary file here. Another dictionary is provided here with FreeRADIUS vendor-specific attributes.</p> <p>For our example, download both files and place it into your project folder.</p> <p>When you see code like this:</p> Loading a dictionary<pre><code>dictfile = dictionary.Dictionary(\"dictionary\")\n</code></pre> <p>You are actually passing a path to a file (or a file-like object) called <code>dictionary</code>, so make sure the file you pass is accessible from your code and it's a valid dictionary file.</p>"},{"location":"getting_started/#radius-server","title":"RADIUS Server","text":"<p>There are two ways of running a server: sync or async. </p> <p>Pick an implementation above and copy the code into your project. This should just work now if you have already installed <code>pyrad2</code>:</p> Running the example server<pre><code>uv run server_async.py\n</code></pre> <p>You should see the logs:</p> <pre><code>2025-07-07 12:38:19.929 | INFO | pyrad2.server_async:connection_made:57 - [127.0.0.1:1812] Transport created\n2025-07-07 12:38:19.929 | INFO | pyrad2.server_async:connection_made:57 - [127.0.0.1:1813] Transport created\n2025-07-07 12:38:19.929 | INFO | pyrad2.server_async:connection_made:57 - [127.0.0.1:3799] Transport created\n</code></pre> <p>Warning</p> <p>Sync support may be dropped in the future. We strongly recommend you use the async version.</p>"},{"location":"getting_started/#handling-packets","title":"Handling packets","text":"<p>Note</p> <p>You may want to jump ahead to the client section in order to make a test request to your server.</p> <p>Fundamentally, you have to subclass the <code>pyrad2</code> server and implement four methods.</p> Methods you have to implement<pre><code>class MyRadiusServer(ServerAsync):\n    def handle_auth_packet(self, protocol, pkt, addr):\n\n    def handle_acct_packet(self, protocol, pkt, addr):\n\n    def handle_coa_packet(self, protocol:, pkt, addr):\n\n    def handle_disconnect_packet(self, protocol, pkt, addr):\n</code></pre> <p>When a packet arrives at these functions it has already been parsed, validated and instantiated into a pyrad2.packet.Packet class.</p> <p>The example implementation provided simply logs details of the request it has just received and it's meant to illustrate the contents of the packet being received.</p> <pre><code>def handle_auth_packet(self, protocol, pkt, addr):\n    logger.info(\"Received an authentication request with id {}\", pkt.id)\n    logger.info(\"Authenticator {}\", pkt.authenticator.hex())\n    logger.info(\"Secret {}\", pkt.secret)\n    logger.info(\"Attributes: \")\n    for attr in pkt.keys():\n        logger.info(\"{}: {}\", attr, pkt[attr])\n</code></pre>"},{"location":"getting_started/#replying","title":"Replying","text":"<p>To reply a packet, you must create a reply packet using <code>self.create_reply_packet</code>. The first argument is the packet you received and you can pass keyword arguments to populate the reply packet.</p> Replying<pre><code>def handle_auth_packet(self, protocol, pkt, addr):\n    ...\n    reply = self.create_reply_packet(\n        pkt,\n        **{\n            \"Service-Type\": \"Framed-User\",\n            \"Framed-IP-Address\": \"192.168.0.1\",\n            \"Framed-IPv6-Prefix\": \"fc66::1/64\",\n        },\n    )\n\n    reply.code = AccessAccept\n    protocol.send_response(reply, addr)\n</code></pre> <p>Lastly, you set the reply code. Possible reply codes can be imported from <code>pyrad2.packet</code>.</p> Reply constants in pyrad2.packet<pre><code>AccessAccept = 2\nAccessReject = 3\nAccountingResponse = 5\nStatusServer = 12\nStatusClient = 13\nDisconnectACK = 41\nDisconnectNAK = 42\nCoAACK = 44\nCoANAK = 45\n</code></pre>"},{"location":"getting_started/#radius-client","title":"RADIUS Client","text":"<p>To instantiate a client you can use <code>ClientAsync</code>. A sync version is also provided in <code>pyrad2.client</code>.</p> <p>Note</p> <p>Both your server and client must be loaded with the same dictionary. Remember, this is how the client and server can understand what it means to use a given attribute code.</p> Instantiating a client<pre><code>from pyrad2.client_async import ClientAsync\nfrom pyrad2.dictionary import Dictionary\n\n\nclient = ClientAsync(\n    server=\"localhost\",\n    secret=b\"Kah3choteereethiejeimaeziecumi\",\n    timeout=4,\n    dict=Dictionary(\"dictionary\"),\n)\n</code></pre> <p>Note</p> <p>In real code, we would never pass the secret hardcoded.</p>"},{"location":"getting_started/#sending-an-authentication-packet","title":"Sending an authentication packet","text":"<p>You can find the example for an auth request here.</p> Making an authentication request<pre><code>$ uv run auth_async.py  # make sure the server is running before\n\n2025-07-07 13:06:36.984 | INFO     | pyrad2.client_async:connection_made:112 - [localhost:3799] Transport created with binding in ::1:62525\n2025-07-07 13:06:36.984 | INFO     | pyrad2.client_async:connection_made:112 - [localhost:1812] Transport created with binding in 127.0.0.1:8000\n2025-07-07 13:06:36.984 | INFO     | pyrad2.client_async:connection_made:112 - [localhost:1813] Transport created with binding in ::1:64970\n2025-07-07 13:06:36.989 | INFO     | __main__:test_auth1:87 - Access accepted\n2025-07-07 13:06:36.989 | INFO     | __main__:test_auth1:91 - Attributes returned by server:\n2025-07-07 13:06:36.989 | INFO     | __main__:test_auth1:93 - Service-Type: ['Framed-User']\n2025-07-07 13:06:36.989 | INFO     | __main__:test_auth1:93 - Framed-IP-Address: ['192.168.0.1']\n2025-07-07 13:06:36.989 | INFO     | __main__:test_auth1:93 - Framed-IPv6-Prefix: ['fc66::/64']\n</code></pre> <p>This is the core code that creates the packet.  </p> <pre><code>def create_request(client, user):\n    req = client.CreateAuthPacket(User_Name=user)\n\n    req[\"NAS-IP-Address\"] = \"192.168.1.10\"\n    req[\"NAS-Port\"] = 0\n    req[\"Service-Type\"] = \"Login-User\"\n    req[\"NAS-Identifier\"] = \"trillian\"\n    req[\"Called-Station-Id\"] = \"00-04-5F-00-0F-D1\"\n    req[\"Calling-Station-Id\"] = \"00-01-24-80-B3-9C\"\n    req[\"Framed-IP-Address\"] = \"10.0.0.100\"\n\n    return req\n</code></pre> <p>You can find a list of standard RADIUS attributes here. Note that these do not include vendor-specific attributes.</p>"},{"location":"getting_started/#setting-attributes","title":"Setting attributes","text":"<p>To set attributes in the <code>Client</code> object, you need to replace underscores with hyphens. So instead of <code>User_Name</code>, you use <code>User-Name</code>. The former is used in python code and the latter is used directly in the underlying data.</p> Naming inconsistencies<pre><code>req = srv.CreateAuthPacket(User_Name=\"wichert\")\n\n# But if acessing the attributes directly\nreq[\"User-Name\"] = \"wichert2\"\nreq[\"NAS-IP-Address\"] = \"192.168.1.10\"\n</code></pre> <p>[Suggestion]: Add some description for the valid arguments that could be passed to CreateAuthPacket.</p>"},{"location":"releases/","title":"Releases","text":""},{"location":"releases/#10-2025-07-07","title":"1.0 (2025-07-07)","text":"<ul> <li>Extensively refactored code</li> <li>Remove legacy Python 2.x/3.x and support only Python 3.12</li> <li>Add typing support to the whole codebase using mypy.</li> <li>Poetry phased out in favour of uv</li> <li>#213 in PyRad fixed.</li> <li>#210 in PyRad merged.</li> <li>Remove <code>nose</code> as it's unmaintained and replace it with pytest. <code>pytest-sugar</code> being used for pretty test output.</li> <li>Added loguru dependency for better log formatting.</li> <li>Modernize AsyncIO code.</li> <li>Update README.md</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/bidict/","title":"BiDict","text":""},{"location":"api/bidict/#pyrad2.bidict.BiDict","title":"<code>BiDict</code>","text":"<p>BiDict (Bidirectional Dictionary) provides a one-to-one mapping between keys and values.</p> <p>Supports both forward and reverse lookup.</p> Source code in <code>pyrad2/bidict.py</code> <pre><code>class BiDict:\n    \"\"\"\n    BiDict (Bidirectional Dictionary) provides a one-to-one mapping\n    between keys and values.\n\n    Supports both forward and reverse lookup.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize empty forward and reverse dictionaries.\"\"\"\n        self.forward: Dict[Hashable, Any] = {}\n        self.backward: Dict[Hashable, Any] = {}\n\n    def Add(self, one: Hashable, two: Hashable) -&gt; None:\n        \"\"\"Add a bidirectional mapping between 'one' and 'two'.\"\"\"\n        self.forward[one] = two\n        self.backward[two] = one\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of entries in the dictionary.\"\"\"\n        return len(self.forward)\n\n    def __getitem__(self, key: Hashable) -&gt; Any:\n        \"\"\"Retrieve the value associated with the given key.\"\"\"\n        return self.GetForward(key)\n\n    def __delitem__(self, key: Hashable) -&gt; None:\n        \"\"\"Remove key and its associated value from the dictionary.\"\"\"\n        if key in self.forward:\n            del self.backward[self.forward[key]]\n            del self.forward[key]\n        else:\n            del self.forward[self.backward[key]]\n            del self.backward[key]\n\n    def GetForward(self, key: Hashable) -&gt; Any:\n        \"\"\"Return the value associated with 'key' from the forward mapping.\"\"\"\n        return self.forward[key]\n\n    def HasForward(self, key: Hashable) -&gt; bool:\n        \"\"\"Check if 'key' exists in the forward mapping.\"\"\"\n        return key in self.forward\n\n    def GetBackward(self, key: Hashable) -&gt; Any:\n        \"\"\"Return the key associated with 'value' from the reverse mapping.\"\"\"\n        return self.backward[key]\n\n    def HasBackward(self, key: Hashable) -&gt; bool:\n        \"\"\"Check if 'value' exists in the reverse mapping.\"\"\"\n        return key in self.backward\n</code></pre>"},{"location":"api/bidict/#pyrad2.bidict.BiDict.Add","title":"<code>Add(one, two)</code>","text":"<p>Add a bidirectional mapping between 'one' and 'two'.</p> Source code in <code>pyrad2/bidict.py</code> <pre><code>def Add(self, one: Hashable, two: Hashable) -&gt; None:\n    \"\"\"Add a bidirectional mapping between 'one' and 'two'.\"\"\"\n    self.forward[one] = two\n    self.backward[two] = one\n</code></pre>"},{"location":"api/bidict/#pyrad2.bidict.BiDict.GetBackward","title":"<code>GetBackward(key)</code>","text":"<p>Return the key associated with 'value' from the reverse mapping.</p> Source code in <code>pyrad2/bidict.py</code> <pre><code>def GetBackward(self, key: Hashable) -&gt; Any:\n    \"\"\"Return the key associated with 'value' from the reverse mapping.\"\"\"\n    return self.backward[key]\n</code></pre>"},{"location":"api/bidict/#pyrad2.bidict.BiDict.GetForward","title":"<code>GetForward(key)</code>","text":"<p>Return the value associated with 'key' from the forward mapping.</p> Source code in <code>pyrad2/bidict.py</code> <pre><code>def GetForward(self, key: Hashable) -&gt; Any:\n    \"\"\"Return the value associated with 'key' from the forward mapping.\"\"\"\n    return self.forward[key]\n</code></pre>"},{"location":"api/bidict/#pyrad2.bidict.BiDict.HasBackward","title":"<code>HasBackward(key)</code>","text":"<p>Check if 'value' exists in the reverse mapping.</p> Source code in <code>pyrad2/bidict.py</code> <pre><code>def HasBackward(self, key: Hashable) -&gt; bool:\n    \"\"\"Check if 'value' exists in the reverse mapping.\"\"\"\n    return key in self.backward\n</code></pre>"},{"location":"api/bidict/#pyrad2.bidict.BiDict.HasForward","title":"<code>HasForward(key)</code>","text":"<p>Check if 'key' exists in the forward mapping.</p> Source code in <code>pyrad2/bidict.py</code> <pre><code>def HasForward(self, key: Hashable) -&gt; bool:\n    \"\"\"Check if 'key' exists in the forward mapping.\"\"\"\n    return key in self.forward\n</code></pre>"},{"location":"api/bidict/#pyrad2.bidict.BiDict.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>Remove key and its associated value from the dictionary.</p> Source code in <code>pyrad2/bidict.py</code> <pre><code>def __delitem__(self, key: Hashable) -&gt; None:\n    \"\"\"Remove key and its associated value from the dictionary.\"\"\"\n    if key in self.forward:\n        del self.backward[self.forward[key]]\n        del self.forward[key]\n    else:\n        del self.forward[self.backward[key]]\n        del self.backward[key]\n</code></pre>"},{"location":"api/bidict/#pyrad2.bidict.BiDict.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Retrieve the value associated with the given key.</p> Source code in <code>pyrad2/bidict.py</code> <pre><code>def __getitem__(self, key: Hashable) -&gt; Any:\n    \"\"\"Retrieve the value associated with the given key.\"\"\"\n    return self.GetForward(key)\n</code></pre>"},{"location":"api/bidict/#pyrad2.bidict.BiDict.__init__","title":"<code>__init__()</code>","text":"<p>Initialize empty forward and reverse dictionaries.</p> Source code in <code>pyrad2/bidict.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize empty forward and reverse dictionaries.\"\"\"\n    self.forward: Dict[Hashable, Any] = {}\n    self.backward: Dict[Hashable, Any] = {}\n</code></pre>"},{"location":"api/bidict/#pyrad2.bidict.BiDict.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of entries in the dictionary.</p> Source code in <code>pyrad2/bidict.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of entries in the dictionary.\"\"\"\n    return len(self.forward)\n</code></pre>"},{"location":"api/client/","title":"Client","text":""},{"location":"api/client/#pyrad2.client.Client","title":"<code>Client</code>","text":"<p>               Bases: <code>Host</code></p> <p>Basic RADIUS client. This class implements a basic RADIUS client. It can send requests to a RADIUS server, taking care of timeouts and retries, and validate its replies.</p> <p>:ivar retries: number of times to retry sending a RADIUS request :type retries: integer :ivar timeout: number of seconds to wait for an answer :type timeout: float</p> Source code in <code>pyrad2/client.py</code> <pre><code>class Client(host.Host):\n    \"\"\"Basic RADIUS client.\n    This class implements a basic RADIUS client. It can send requests\n    to a RADIUS server, taking care of timeouts and retries, and\n    validate its replies.\n\n    :ivar retries: number of times to retry sending a RADIUS request\n    :type retries: integer\n    :ivar timeout: number of seconds to wait for an answer\n    :type timeout: float\n    \"\"\"\n\n    def __init__(\n        self,\n        server: str,\n        authport: int = 1812,\n        acctport: int = 1813,\n        coaport: int = 3799,\n        secret: bytes = b\"\",\n        dict: Optional[Dictionary] = None,\n        retries: int = 3,\n        timeout: int = 5,\n    ):\n        \"\"\"Constructor.\n\n        :param   server: hostname or IP address of RADIUS server\n        :type    server: string\n        :param authport: port to use for authentication packets\n        :type  authport: integer\n        :param acctport: port to use for accounting packets\n        :type  acctport: integer\n        :param coaport: port to use for CoA packets\n        :type  coaport: integer\n        :param   secret: RADIUS secret\n        :type    secret: string\n        :param     dict: RADIUS dictionary\n        :type      dict: pyrad.dictionary.Dictionary\n        \"\"\"\n        super().__init__(authport, acctport, coaport, dict)\n\n        self.server = server\n        self.secret = secret\n        self.retries = retries\n        self.timeout = timeout\n        self._poll = select.poll()\n        self._socket: Optional[socket.socket] = None\n\n    def bind(self, addr: str) -&gt; None:\n        \"\"\"Bind socket to an address.\n        Binding the socket used for communicating to an address can be\n        usefull when working on a machine with multiple addresses.\n\n        :param addr: network address (hostname or IP) and port to bind to\n        :type  addr: host,port tuple\n        \"\"\"\n        self._CloseSocket()\n        self._SocketOpen()\n        if self._socket:\n            self._socket.bind(addr)\n        else:\n            raise RuntimeError(\"No socket present\")\n\n    def _SocketOpen(self) -&gt; None:\n        try:\n            family = socket.getaddrinfo(self.server, 80)[0][0]\n        except Exception:\n            family = socket.AF_INET\n        if not self._socket:\n            self._socket = socket.socket(family, socket.SOCK_DGRAM)\n            self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            self._poll.register(self._socket, select.POLLIN)\n\n    def _CloseSocket(self) -&gt; None:\n        if self._socket:\n            self._poll.unregister(self._socket)\n            self._socket.close()\n            self._socket = None\n\n    def CreateAuthPacket(self, **args) -&gt; packet.Packet:\n        \"\"\"Create a new RADIUS packet.\n        This utility function creates a new RADIUS packet which can\n        be used to communicate with the RADIUS server this client\n        talks to. This is initializing the new packet with the\n        dictionary and secret used for the client.\n\n        :return: a new empty packet instance\n        :rtype:  pyrad.packet.AuthPacket\n        \"\"\"\n        return super().CreateAuthPacket(secret=self.secret, **args)\n\n    def CreateAcctPacket(self, **args) -&gt; packet.Packet:\n        \"\"\"Create a new RADIUS packet.\n        This utility function creates a new RADIUS packet which can\n        be used to communicate with the RADIUS server this client\n        talks to. This is initializing the new packet with the\n        dictionary and secret used for the client.\n\n        :return: a new empty packet instance\n        :rtype:  pyrad.packet.Packet\n        \"\"\"\n        return super().CreateAcctPacket(secret=self.secret, **args)\n\n    def CreateCoAPacket(self, **args) -&gt; packet.Packet:\n        \"\"\"Create a new RADIUS packet.\n        This utility function creates a new RADIUS packet which can\n        be used to communicate with the RADIUS server this client\n        talks to. This is initializing the new packet with the\n        dictionary and secret used for the client.\n\n        :return: a new empty packet instance\n        :rtype:  pyrad.packet.Packet\n        \"\"\"\n        return super().CreateCoAPacket(secret=self.secret, **args)\n\n    def _SendPacket(self, pkt: packet.PacketImplementation, port: int):\n        \"\"\"Send a packet to a RADIUS server.\n\n        :param pkt:  the packet to send\n        :type pkt:   pyrad.packet.Packet\n        :param port: UDP port to send packet to\n        :type port:  integer\n        :return:     the reply packet received\n        :rtype:      pyrad.packet.Packet\n        :raise Timeout: RADIUS server does not reply\n        \"\"\"\n        self._SocketOpen()\n\n        for attempt in range(self.retries):\n            if attempt and pkt.code == packet.AccountingRequest:\n                if \"Acct-Delay-Time\" in pkt:\n                    pkt[\"Acct-Delay-Time\"] = pkt[\"Acct-Delay-Time\"][0] + self.timeout\n                else:\n                    pkt[\"Acct-Delay-Time\"] = self.timeout\n\n            now = time.time()\n            waitto = now + self.timeout\n\n            if not self._socket:\n                raise RuntimeError(\"No socket present\")\n\n            self._socket.sendto(pkt.RequestPacket(), (self.server, port))\n\n            while now &lt; waitto:\n                ready = self._poll.poll((waitto - now) * 1000)\n\n                if ready:\n                    rawreply = self._socket.recv(4096)\n                else:\n                    now = time.time()\n                    continue\n\n                try:\n                    reply = pkt.CreateReply(packet=rawreply)\n                    if pkt.VerifyReply(reply, rawreply):\n                        return reply\n                except packet.PacketError:\n                    pass\n\n                now = time.time()\n\n        raise Timeout\n\n    def SendPacket(self, pkt: packet.PacketImplementation):  # type: ignore\n        \"\"\"Send a packet to a RADIUS server.\n\n        :param pkt: the packet to send\n        :type pkt:  pyrad.packet.Packet\n        :return:    the reply packet received\n        :rtype:     pyrad.packet.Packet\n        :raise Timeout: RADIUS server does not reply\n        \"\"\"\n        if isinstance(pkt, packet.AuthPacket):\n            if pkt.auth_type == \"eap-md5\":\n                # Creating EAP-Identity\n                password = pkt[2][0] if 2 in pkt else pkt[1][0]\n                pkt[79] = [\n                    struct.pack(\n                        \"!BBHB%ds\" % len(password),\n                        EAP_CODE_RESPONSE,\n                        packet.CurrentID,\n                        len(password) + 5,\n                        EAP_TYPE_IDENTITY,\n                        password,\n                    )\n                ]\n            reply = self._SendPacket(pkt, self.authport)\n            if (\n                reply\n                and reply.code == packet.AccessChallenge\n                and pkt.auth_type == \"eap-md5\"\n            ):\n                # Got an Access-Challenge\n                eap_code, eap_id, eap_size, eap_type, eap_md5 = struct.unpack(\n                    \"!BBHB%ds\" % (len(reply[79][0]) - 5), reply[79][0]\n                )\n                # Sending back an EAP-Type-MD5-Challenge\n                # Thank god for http://www.secdev.org/python/eapy.py\n                client_pw = pkt[2][0] if 2 in pkt else pkt[1][0]\n                md5_challenge = hashlib.md5(\n                    struct.pack(\"!B\", eap_id) + client_pw + eap_md5[1:]\n                ).digest()\n                pkt[79] = [\n                    struct.pack(\n                        \"!BBHBB\",\n                        2,\n                        eap_id,\n                        len(md5_challenge) + 6,\n                        4,\n                        len(md5_challenge),\n                    )\n                    + md5_challenge\n                ]\n                # Copy over Challenge-State\n                pkt[24] = reply[24]\n                reply = self._SendPacket(pkt, self.authport)\n            return reply\n        elif isinstance(pkt, packet.CoAPacket):\n            return self._SendPacket(pkt, self.coaport)\n        else:\n            return self._SendPacket(pkt, self.acctport)\n</code></pre>"},{"location":"api/client/#pyrad2.client.Client.CreateAcctPacket","title":"<code>CreateAcctPacket(**args)</code>","text":"<p>Create a new RADIUS packet. This utility function creates a new RADIUS packet which can be used to communicate with the RADIUS server this client talks to. This is initializing the new packet with the dictionary and secret used for the client.</p> <p>:return: a new empty packet instance :rtype:  pyrad.packet.Packet</p> Source code in <code>pyrad2/client.py</code> <pre><code>def CreateAcctPacket(self, **args) -&gt; packet.Packet:\n    \"\"\"Create a new RADIUS packet.\n    This utility function creates a new RADIUS packet which can\n    be used to communicate with the RADIUS server this client\n    talks to. This is initializing the new packet with the\n    dictionary and secret used for the client.\n\n    :return: a new empty packet instance\n    :rtype:  pyrad.packet.Packet\n    \"\"\"\n    return super().CreateAcctPacket(secret=self.secret, **args)\n</code></pre>"},{"location":"api/client/#pyrad2.client.Client.CreateAuthPacket","title":"<code>CreateAuthPacket(**args)</code>","text":"<p>Create a new RADIUS packet. This utility function creates a new RADIUS packet which can be used to communicate with the RADIUS server this client talks to. This is initializing the new packet with the dictionary and secret used for the client.</p> <p>:return: a new empty packet instance :rtype:  pyrad.packet.AuthPacket</p> Source code in <code>pyrad2/client.py</code> <pre><code>def CreateAuthPacket(self, **args) -&gt; packet.Packet:\n    \"\"\"Create a new RADIUS packet.\n    This utility function creates a new RADIUS packet which can\n    be used to communicate with the RADIUS server this client\n    talks to. This is initializing the new packet with the\n    dictionary and secret used for the client.\n\n    :return: a new empty packet instance\n    :rtype:  pyrad.packet.AuthPacket\n    \"\"\"\n    return super().CreateAuthPacket(secret=self.secret, **args)\n</code></pre>"},{"location":"api/client/#pyrad2.client.Client.CreateCoAPacket","title":"<code>CreateCoAPacket(**args)</code>","text":"<p>Create a new RADIUS packet. This utility function creates a new RADIUS packet which can be used to communicate with the RADIUS server this client talks to. This is initializing the new packet with the dictionary and secret used for the client.</p> <p>:return: a new empty packet instance :rtype:  pyrad.packet.Packet</p> Source code in <code>pyrad2/client.py</code> <pre><code>def CreateCoAPacket(self, **args) -&gt; packet.Packet:\n    \"\"\"Create a new RADIUS packet.\n    This utility function creates a new RADIUS packet which can\n    be used to communicate with the RADIUS server this client\n    talks to. This is initializing the new packet with the\n    dictionary and secret used for the client.\n\n    :return: a new empty packet instance\n    :rtype:  pyrad.packet.Packet\n    \"\"\"\n    return super().CreateCoAPacket(secret=self.secret, **args)\n</code></pre>"},{"location":"api/client/#pyrad2.client.Client.SendPacket","title":"<code>SendPacket(pkt)</code>","text":"<p>Send a packet to a RADIUS server.</p> <p>:param pkt: the packet to send :type pkt:  pyrad.packet.Packet :return:    the reply packet received :rtype:     pyrad.packet.Packet :raise Timeout: RADIUS server does not reply</p> Source code in <code>pyrad2/client.py</code> <pre><code>def SendPacket(self, pkt: packet.PacketImplementation):  # type: ignore\n    \"\"\"Send a packet to a RADIUS server.\n\n    :param pkt: the packet to send\n    :type pkt:  pyrad.packet.Packet\n    :return:    the reply packet received\n    :rtype:     pyrad.packet.Packet\n    :raise Timeout: RADIUS server does not reply\n    \"\"\"\n    if isinstance(pkt, packet.AuthPacket):\n        if pkt.auth_type == \"eap-md5\":\n            # Creating EAP-Identity\n            password = pkt[2][0] if 2 in pkt else pkt[1][0]\n            pkt[79] = [\n                struct.pack(\n                    \"!BBHB%ds\" % len(password),\n                    EAP_CODE_RESPONSE,\n                    packet.CurrentID,\n                    len(password) + 5,\n                    EAP_TYPE_IDENTITY,\n                    password,\n                )\n            ]\n        reply = self._SendPacket(pkt, self.authport)\n        if (\n            reply\n            and reply.code == packet.AccessChallenge\n            and pkt.auth_type == \"eap-md5\"\n        ):\n            # Got an Access-Challenge\n            eap_code, eap_id, eap_size, eap_type, eap_md5 = struct.unpack(\n                \"!BBHB%ds\" % (len(reply[79][0]) - 5), reply[79][0]\n            )\n            # Sending back an EAP-Type-MD5-Challenge\n            # Thank god for http://www.secdev.org/python/eapy.py\n            client_pw = pkt[2][0] if 2 in pkt else pkt[1][0]\n            md5_challenge = hashlib.md5(\n                struct.pack(\"!B\", eap_id) + client_pw + eap_md5[1:]\n            ).digest()\n            pkt[79] = [\n                struct.pack(\n                    \"!BBHBB\",\n                    2,\n                    eap_id,\n                    len(md5_challenge) + 6,\n                    4,\n                    len(md5_challenge),\n                )\n                + md5_challenge\n            ]\n            # Copy over Challenge-State\n            pkt[24] = reply[24]\n            reply = self._SendPacket(pkt, self.authport)\n        return reply\n    elif isinstance(pkt, packet.CoAPacket):\n        return self._SendPacket(pkt, self.coaport)\n    else:\n        return self._SendPacket(pkt, self.acctport)\n</code></pre>"},{"location":"api/client/#pyrad2.client.Client.__init__","title":"<code>__init__(server, authport=1812, acctport=1813, coaport=3799, secret=b'', dict=None, retries=3, timeout=5)</code>","text":"<p>Constructor.</p> <p>:param   server: hostname or IP address of RADIUS server :type    server: string :param authport: port to use for authentication packets :type  authport: integer :param acctport: port to use for accounting packets :type  acctport: integer :param coaport: port to use for CoA packets :type  coaport: integer :param   secret: RADIUS secret :type    secret: string :param     dict: RADIUS dictionary :type      dict: pyrad.dictionary.Dictionary</p> Source code in <code>pyrad2/client.py</code> <pre><code>def __init__(\n    self,\n    server: str,\n    authport: int = 1812,\n    acctport: int = 1813,\n    coaport: int = 3799,\n    secret: bytes = b\"\",\n    dict: Optional[Dictionary] = None,\n    retries: int = 3,\n    timeout: int = 5,\n):\n    \"\"\"Constructor.\n\n    :param   server: hostname or IP address of RADIUS server\n    :type    server: string\n    :param authport: port to use for authentication packets\n    :type  authport: integer\n    :param acctport: port to use for accounting packets\n    :type  acctport: integer\n    :param coaport: port to use for CoA packets\n    :type  coaport: integer\n    :param   secret: RADIUS secret\n    :type    secret: string\n    :param     dict: RADIUS dictionary\n    :type      dict: pyrad.dictionary.Dictionary\n    \"\"\"\n    super().__init__(authport, acctport, coaport, dict)\n\n    self.server = server\n    self.secret = secret\n    self.retries = retries\n    self.timeout = timeout\n    self._poll = select.poll()\n    self._socket: Optional[socket.socket] = None\n</code></pre>"},{"location":"api/client/#pyrad2.client.Client.bind","title":"<code>bind(addr)</code>","text":"<p>Bind socket to an address. Binding the socket used for communicating to an address can be usefull when working on a machine with multiple addresses.</p> <p>:param addr: network address (hostname or IP) and port to bind to :type  addr: host,port tuple</p> Source code in <code>pyrad2/client.py</code> <pre><code>def bind(self, addr: str) -&gt; None:\n    \"\"\"Bind socket to an address.\n    Binding the socket used for communicating to an address can be\n    usefull when working on a machine with multiple addresses.\n\n    :param addr: network address (hostname or IP) and port to bind to\n    :type  addr: host,port tuple\n    \"\"\"\n    self._CloseSocket()\n    self._SocketOpen()\n    if self._socket:\n        self._socket.bind(addr)\n    else:\n        raise RuntimeError(\"No socket present\")\n</code></pre>"},{"location":"api/client/#pyrad2.client.Timeout","title":"<code>Timeout</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Simple exception class which is raised when a timeout occurs while waiting for a RADIUS server to respond.</p> Source code in <code>pyrad2/client.py</code> <pre><code>class Timeout(Exception):\n    \"\"\"Simple exception class which is raised when a timeout occurs\n    while waiting for a RADIUS server to respond.\"\"\"\n</code></pre>"},{"location":"api/client_async/","title":"Client Async","text":""},{"location":"api/client_async/#pyrad2.client_async.ClientAsync","title":"<code>ClientAsync</code>","text":"<p>Basic RADIUS client. This class implements a basic RADIUS client. It can send requests to a RADIUS server, taking care of timeouts and retries, and validate its replies.</p> <p>:ivar retries: number of times to retry sending a RADIUS request :type retries: integer :ivar timeout: number of seconds to wait for an answer :type timeout: integer</p> Source code in <code>pyrad2/client_async.py</code> <pre><code>class ClientAsync:\n    \"\"\"Basic RADIUS client.\n    This class implements a basic RADIUS client. It can send requests\n    to a RADIUS server, taking care of timeouts and retries, and\n    validate its replies.\n\n    :ivar retries: number of times to retry sending a RADIUS request\n    :type retries: integer\n    :ivar timeout: number of seconds to wait for an answer\n    :type timeout: integer\n    \"\"\"\n\n    def __init__(\n        self,\n        server: str,\n        auth_port: int = 1812,\n        acct_port: int = 1813,\n        coa_port: int = 3799,\n        secret: bytes = b\"\",\n        dict: Optional[Dictionary] = None,\n        retries: int = 3,\n        timeout: int = 30,\n    ):\n        \"\"\"Constructor.\n\n        :param    server: hostname or IP address of RADIUS server\n        :type     server: string\n        :param auth_port: port to use for authentication packets\n        :type  auth_port: integer\n        :param acct_port: port to use for accounting packets\n        :type  acct_port: integer\n        :param  coa_port: port to use for CoA packets\n        :type   coa_port: integer\n        :param    secret: RADIUS secret\n        :type     secret: string\n        :param      dict: RADIUS dictionary\n        :type       dict: pyrad.dictionary.Dictionary\n        :param      loop: Python loop handler\n        :type       loop:  asyncio event loop\n        \"\"\"\n        self.server = server\n        self.secret = secret\n        self.retries = retries\n        self.timeout = timeout\n        self.dict = dict\n\n        self.auth_port = auth_port\n        self.protocol_auth: Optional[DatagramProtocolClient] = None\n\n        self.acct_port = acct_port\n        self.protocol_acct: Optional[DatagramProtocolClient] = None\n\n        self.protocol_coa: Optional[DatagramProtocolClient] = None\n        self.coa_port = coa_port\n\n    async def initialize_transports(\n        self,\n        enable_acct: bool = False,\n        enable_auth: bool = False,\n        enable_coa: bool = False,\n        local_addr: Optional[str] = None,\n        local_auth_port: Optional[int] = None,\n        local_acct_port: Optional[int] = None,\n        local_coa_port: Optional[int] = None,\n    ):\n        task_list = []\n\n        if not enable_acct and not enable_auth and not enable_coa:\n            raise Exception(\"No transports selected\")\n\n        loop = asyncio.get_event_loop()\n        if enable_acct and not self.protocol_acct:\n            self.protocol_acct = DatagramProtocolClient(\n                self.server,\n                self.acct_port,\n                self,\n                retries=self.retries,\n                timeout=self.timeout,\n            )\n            bind_addr = None\n            if local_addr and local_acct_port:\n                bind_addr = (local_addr, local_acct_port)\n\n            acct_connect = loop.create_datagram_endpoint(\n                self.protocol_acct,\n                reuse_port=True,\n                remote_addr=(self.server, self.acct_port),\n                local_addr=bind_addr,\n            )\n            task_list.append(acct_connect)\n\n        if enable_auth and not self.protocol_auth:\n            self.protocol_auth = DatagramProtocolClient(\n                self.server,\n                self.auth_port,\n                self,\n                retries=self.retries,\n                timeout=self.timeout,\n            )\n            bind_addr = None\n            if local_addr and local_auth_port:\n                bind_addr = (local_addr, local_auth_port)\n\n            auth_connect = loop.create_datagram_endpoint(\n                self.protocol_auth,\n                reuse_port=True,\n                remote_addr=(self.server, self.auth_port),\n                local_addr=bind_addr,\n            )\n            task_list.append(auth_connect)\n\n        if enable_coa and not self.protocol_coa:\n            self.protocol_coa = DatagramProtocolClient(\n                self.server,\n                self.coa_port,\n                self,\n                retries=self.retries,\n                timeout=self.timeout,\n            )\n            bind_addr = None\n            if local_addr and local_coa_port:\n                bind_addr = (local_addr, local_coa_port)\n\n            coa_connect = loop.create_datagram_endpoint(\n                self.protocol_coa,\n                reuse_port=True,\n                remote_addr=(self.server, self.coa_port),\n                local_addr=bind_addr,\n            )\n            task_list.append(coa_connect)\n\n        await asyncio.ensure_future(\n            asyncio.gather(\n                *task_list,\n                return_exceptions=False,\n            ),\n            loop=loop,\n        )\n\n    async def deinitialize_transports(\n        self,\n        deinit_coa: bool = True,\n        deinit_auth: bool = True,\n        deinit_acct: bool = True,\n    ) -&gt; None:\n        if self.protocol_coa and deinit_coa:\n            await self.protocol_coa.close_transport()\n            del self.protocol_coa\n            self.protocol_coa = None\n        if self.protocol_auth and deinit_auth:\n            await self.protocol_auth.close_transport()\n            del self.protocol_auth\n            self.protocol_auth = None\n        if self.protocol_acct and deinit_acct:\n            await self.protocol_acct.close_transport()\n            del self.protocol_acct\n            self.protocol_acct = None\n\n    def CreateAuthPacket(self, **args) -&gt; AuthPacket:\n        \"\"\"Create a new RADIUS packet.\n        This utility function creates a new RADIUS packet which can\n        be used to communicate with the RADIUS server this client\n        talks to. This is initializing the new packet with the\n        dictionary and secret used for the client.\n\n        :return: a new empty packet instance\n        :rtype:  pyrad.packet.Packet\n        \"\"\"\n        if not self.protocol_auth:\n            raise Exception(\"Transport not initialized\")\n\n        return AuthPacket(\n            dict=self.dict,\n            id=self.protocol_auth.create_id(),\n            secret=self.secret,\n            **args,\n        )\n\n    def CreateAcctPacket(self, **args) -&gt; AcctPacket:\n        \"\"\"Create a new RADIUS packet.\n        This utility function creates a new RADIUS packet which can\n        be used to communicate with the RADIUS server this client\n        talks to. This is initializing the new packet with the\n        dictionary and secret used for the client.\n\n        :return: a new empty packet instance\n        :rtype:  pyrad.packet.Packet\n        \"\"\"\n        if not self.protocol_acct:\n            raise Exception(\"Transport not initialized\")\n\n        return AcctPacket(\n            id=self.protocol_acct.create_id(),\n            dict=self.dict,\n            secret=self.secret,\n            **args,\n        )\n\n    def CreateCoAPacket(self, **args) -&gt; CoAPacket:\n        \"\"\"Create a new RADIUS packet.\n        This utility function creates a new RADIUS packet which can\n        be used to communicate with the RADIUS server this client\n        talks to. This is initializing the new packet with the\n        dictionary and secret used for the client.\n\n        :return: a new empty packet instance\n        :rtype:  pyrad.packet.Packet\n        \"\"\"\n\n        if not self.protocol_coa:\n            raise Exception(\"Transport not initialized\")\n\n        return CoAPacket(\n            id=self.protocol_coa.create_id(), dict=self.dict, secret=self.secret, **args\n        )\n\n    def CreatePacket(self, id: int, **args) -&gt; Packet:\n        if not id:\n            raise Exception(\"Missing mandatory packet id\")\n\n        return Packet(id=id, dict=self.dict, secret=self.secret, **args)\n\n    def SendPacket(self, pkt: Packet) -&gt; asyncio.Future:\n        \"\"\"Send a packet to a RADIUS server.\n\n        :param pkt: the packet to send\n        :type  pkt: pyrad.packet.Packet\n        :return:    Future related with packet to send\n        :rtype:     asyncio.Future\n        \"\"\"\n\n        ans: asyncio.Future = asyncio.Future(loop=asyncio.get_event_loop())\n\n        if isinstance(pkt, AuthPacket):\n            if not self.protocol_auth:\n                raise Exception(\"Transport not initialized\")\n\n            self.protocol_auth.send_packet(pkt, ans)\n\n        elif isinstance(pkt, AcctPacket):\n            if not self.protocol_acct:\n                raise Exception(\"Transport not initialized\")\n\n            self.protocol_acct.send_packet(pkt, ans)\n\n        elif isinstance(pkt, CoAPacket):\n            if not self.protocol_coa:\n                raise Exception(\"Transport not initialized\")\n\n            self.protocol_coa.send_packet(pkt, ans)\n\n        else:\n            raise Exception(\"Unsupported packet\")\n\n        return ans\n</code></pre>"},{"location":"api/client_async/#pyrad2.client_async.ClientAsync.CreateAcctPacket","title":"<code>CreateAcctPacket(**args)</code>","text":"<p>Create a new RADIUS packet. This utility function creates a new RADIUS packet which can be used to communicate with the RADIUS server this client talks to. This is initializing the new packet with the dictionary and secret used for the client.</p> <p>:return: a new empty packet instance :rtype:  pyrad.packet.Packet</p> Source code in <code>pyrad2/client_async.py</code> <pre><code>def CreateAcctPacket(self, **args) -&gt; AcctPacket:\n    \"\"\"Create a new RADIUS packet.\n    This utility function creates a new RADIUS packet which can\n    be used to communicate with the RADIUS server this client\n    talks to. This is initializing the new packet with the\n    dictionary and secret used for the client.\n\n    :return: a new empty packet instance\n    :rtype:  pyrad.packet.Packet\n    \"\"\"\n    if not self.protocol_acct:\n        raise Exception(\"Transport not initialized\")\n\n    return AcctPacket(\n        id=self.protocol_acct.create_id(),\n        dict=self.dict,\n        secret=self.secret,\n        **args,\n    )\n</code></pre>"},{"location":"api/client_async/#pyrad2.client_async.ClientAsync.CreateAuthPacket","title":"<code>CreateAuthPacket(**args)</code>","text":"<p>Create a new RADIUS packet. This utility function creates a new RADIUS packet which can be used to communicate with the RADIUS server this client talks to. This is initializing the new packet with the dictionary and secret used for the client.</p> <p>:return: a new empty packet instance :rtype:  pyrad.packet.Packet</p> Source code in <code>pyrad2/client_async.py</code> <pre><code>def CreateAuthPacket(self, **args) -&gt; AuthPacket:\n    \"\"\"Create a new RADIUS packet.\n    This utility function creates a new RADIUS packet which can\n    be used to communicate with the RADIUS server this client\n    talks to. This is initializing the new packet with the\n    dictionary and secret used for the client.\n\n    :return: a new empty packet instance\n    :rtype:  pyrad.packet.Packet\n    \"\"\"\n    if not self.protocol_auth:\n        raise Exception(\"Transport not initialized\")\n\n    return AuthPacket(\n        dict=self.dict,\n        id=self.protocol_auth.create_id(),\n        secret=self.secret,\n        **args,\n    )\n</code></pre>"},{"location":"api/client_async/#pyrad2.client_async.ClientAsync.CreateCoAPacket","title":"<code>CreateCoAPacket(**args)</code>","text":"<p>Create a new RADIUS packet. This utility function creates a new RADIUS packet which can be used to communicate with the RADIUS server this client talks to. This is initializing the new packet with the dictionary and secret used for the client.</p> <p>:return: a new empty packet instance :rtype:  pyrad.packet.Packet</p> Source code in <code>pyrad2/client_async.py</code> <pre><code>def CreateCoAPacket(self, **args) -&gt; CoAPacket:\n    \"\"\"Create a new RADIUS packet.\n    This utility function creates a new RADIUS packet which can\n    be used to communicate with the RADIUS server this client\n    talks to. This is initializing the new packet with the\n    dictionary and secret used for the client.\n\n    :return: a new empty packet instance\n    :rtype:  pyrad.packet.Packet\n    \"\"\"\n\n    if not self.protocol_coa:\n        raise Exception(\"Transport not initialized\")\n\n    return CoAPacket(\n        id=self.protocol_coa.create_id(), dict=self.dict, secret=self.secret, **args\n    )\n</code></pre>"},{"location":"api/client_async/#pyrad2.client_async.ClientAsync.SendPacket","title":"<code>SendPacket(pkt)</code>","text":"<p>Send a packet to a RADIUS server.</p> <p>:param pkt: the packet to send :type  pkt: pyrad.packet.Packet :return:    Future related with packet to send :rtype:     asyncio.Future</p> Source code in <code>pyrad2/client_async.py</code> <pre><code>def SendPacket(self, pkt: Packet) -&gt; asyncio.Future:\n    \"\"\"Send a packet to a RADIUS server.\n\n    :param pkt: the packet to send\n    :type  pkt: pyrad.packet.Packet\n    :return:    Future related with packet to send\n    :rtype:     asyncio.Future\n    \"\"\"\n\n    ans: asyncio.Future = asyncio.Future(loop=asyncio.get_event_loop())\n\n    if isinstance(pkt, AuthPacket):\n        if not self.protocol_auth:\n            raise Exception(\"Transport not initialized\")\n\n        self.protocol_auth.send_packet(pkt, ans)\n\n    elif isinstance(pkt, AcctPacket):\n        if not self.protocol_acct:\n            raise Exception(\"Transport not initialized\")\n\n        self.protocol_acct.send_packet(pkt, ans)\n\n    elif isinstance(pkt, CoAPacket):\n        if not self.protocol_coa:\n            raise Exception(\"Transport not initialized\")\n\n        self.protocol_coa.send_packet(pkt, ans)\n\n    else:\n        raise Exception(\"Unsupported packet\")\n\n    return ans\n</code></pre>"},{"location":"api/client_async/#pyrad2.client_async.ClientAsync.__init__","title":"<code>__init__(server, auth_port=1812, acct_port=1813, coa_port=3799, secret=b'', dict=None, retries=3, timeout=30)</code>","text":"<p>Constructor.</p> <p>:param    server: hostname or IP address of RADIUS server :type     server: string :param auth_port: port to use for authentication packets :type  auth_port: integer :param acct_port: port to use for accounting packets :type  acct_port: integer :param  coa_port: port to use for CoA packets :type   coa_port: integer :param    secret: RADIUS secret :type     secret: string :param      dict: RADIUS dictionary :type       dict: pyrad.dictionary.Dictionary :param      loop: Python loop handler :type       loop:  asyncio event loop</p> Source code in <code>pyrad2/client_async.py</code> <pre><code>def __init__(\n    self,\n    server: str,\n    auth_port: int = 1812,\n    acct_port: int = 1813,\n    coa_port: int = 3799,\n    secret: bytes = b\"\",\n    dict: Optional[Dictionary] = None,\n    retries: int = 3,\n    timeout: int = 30,\n):\n    \"\"\"Constructor.\n\n    :param    server: hostname or IP address of RADIUS server\n    :type     server: string\n    :param auth_port: port to use for authentication packets\n    :type  auth_port: integer\n    :param acct_port: port to use for accounting packets\n    :type  acct_port: integer\n    :param  coa_port: port to use for CoA packets\n    :type   coa_port: integer\n    :param    secret: RADIUS secret\n    :type     secret: string\n    :param      dict: RADIUS dictionary\n    :type       dict: pyrad.dictionary.Dictionary\n    :param      loop: Python loop handler\n    :type       loop:  asyncio event loop\n    \"\"\"\n    self.server = server\n    self.secret = secret\n    self.retries = retries\n    self.timeout = timeout\n    self.dict = dict\n\n    self.auth_port = auth_port\n    self.protocol_auth: Optional[DatagramProtocolClient] = None\n\n    self.acct_port = acct_port\n    self.protocol_acct: Optional[DatagramProtocolClient] = None\n\n    self.protocol_coa: Optional[DatagramProtocolClient] = None\n    self.coa_port = coa_port\n</code></pre>"},{"location":"api/dictfile/","title":"DictFile","text":"<p>Dictionary File</p> <p>Implements an iterable file format that handles the RADIUS $INCLUDE directives behind the scene.</p>"},{"location":"api/dictfile/#pyrad2.dictfile.DictFile","title":"<code>DictFile</code>","text":"<p>Dictionary file class</p> <p>An iterable file type that handles $INCLUDE directives internally.</p> Source code in <code>pyrad2/dictfile.py</code> <pre><code>class DictFile:\n    \"\"\"Dictionary file class\n\n    An iterable file type that handles $INCLUDE\n    directives internally.\n    \"\"\"\n\n    __slots__ = \"stack\"\n\n    def __init__(self, fil: str | io.TextIOWrapper) -&gt; None:\n        \"\"\"\n        @param fil: a dictionary file to parse\n        @type fil: string or file\n        \"\"\"\n        self.stack: list[_Node] = []\n        self.__ReadNode(fil)\n\n    def __ReadNode(self, fil: str | io.TextIOWrapper) -&gt; None:\n        parentdir = self.__CurDir()\n        if isinstance(fil, str):\n            if os.path.isabs(fil):\n                fname = fil\n            else:\n                fname = os.path.join(parentdir, fil)\n            fd = open(fname)\n            node = _Node(fd, fil, parentdir)\n            fd.close()\n        else:\n            node = _Node(fil, \"\", parentdir)\n        self.stack.append(node)\n\n    def __CurDir(self) -&gt; str:\n        if self.stack:\n            return self.stack[-1].dir\n        else:\n            return os.path.realpath(os.curdir)\n\n    def __GetInclude(self, line: str) -&gt; Optional[str]:\n        line = line.split(\"#\", 1)[0].strip()\n        tokens = line.split()\n        if tokens and tokens[0].upper() == \"$INCLUDE\":\n            return \" \".join(tokens[1:])\n        else:\n            return None\n\n    def Line(self) -&gt; int:\n        \"\"\"Returns line number of current file\"\"\"\n        if self.stack:\n            return self.stack[-1].current\n        else:\n            return -1\n\n    def File(self) -&gt; str:\n        \"\"\"Returns name of current file\"\"\"\n        if self.stack:\n            return self.stack[-1].name\n        else:\n            return \"\"\n\n    def __iter__(self) -&gt; Self:\n        return self\n\n    def __next__(self) -&gt; str:\n        while self.stack:\n            line = self.stack[-1].Next()\n            if line is None:\n                self.stack.pop()\n            else:\n                inc = self.__GetInclude(line)\n                if inc:\n                    self.__ReadNode(inc)\n                else:\n                    return line\n        raise StopIteration\n\n    next = __next__  # BBB for python &lt;3\n</code></pre>"},{"location":"api/dictfile/#pyrad2.dictfile.DictFile.File","title":"<code>File()</code>","text":"<p>Returns name of current file</p> Source code in <code>pyrad2/dictfile.py</code> <pre><code>def File(self) -&gt; str:\n    \"\"\"Returns name of current file\"\"\"\n    if self.stack:\n        return self.stack[-1].name\n    else:\n        return \"\"\n</code></pre>"},{"location":"api/dictfile/#pyrad2.dictfile.DictFile.Line","title":"<code>Line()</code>","text":"<p>Returns line number of current file</p> Source code in <code>pyrad2/dictfile.py</code> <pre><code>def Line(self) -&gt; int:\n    \"\"\"Returns line number of current file\"\"\"\n    if self.stack:\n        return self.stack[-1].current\n    else:\n        return -1\n</code></pre>"},{"location":"api/dictfile/#pyrad2.dictfile.DictFile.__init__","title":"<code>__init__(fil)</code>","text":"<p>@param fil: a dictionary file to parse @type fil: string or file</p> Source code in <code>pyrad2/dictfile.py</code> <pre><code>def __init__(self, fil: str | io.TextIOWrapper) -&gt; None:\n    \"\"\"\n    @param fil: a dictionary file to parse\n    @type fil: string or file\n    \"\"\"\n    self.stack: list[_Node] = []\n    self.__ReadNode(fil)\n</code></pre>"},{"location":"api/dictionary/","title":"Dictionary","text":"<p>RADIUS uses dictionaries to define the attributes that can be used in packets. The Dictionary class stores the attribute definitions from one or more dictionary files.</p> <p>Dictionary files are textfiles with one command per line. Comments are specified by starting with a # character, and empty lines are ignored.</p> <p>The commands supported are::</p> <p>ATTRIBUTE  <code>  []   specify an attribute and its type <p>VALUE     specify a value attribute <p>VENDOR     specify a vendor ID <p>BEGIN-VENDOR    begin definition of vendor attributes <p>END-VENDOR    end definition of vendor attributes <p>The datatypes currently supported are:</p> <p>+---------------+----------------------------------------------+ | type          | description                                  | +===============+==============================================+ | string        | ASCII string                                 | +---------------+----------------------------------------------+ | ipaddr        | IPv4 address                                 | +---------------+----------------------------------------------+ | date          | 32 bits UNIX                                 | +---------------+----------------------------------------------+ | octets        | arbitrary binary data                        | +---------------+----------------------------------------------+ | abinary       | ascend binary data                           | +---------------+----------------------------------------------+ | ipv6addr      | 16 octets in network byte order              | +---------------+----------------------------------------------+ | ipv6prefix    | 18 octets in network byte order              | +---------------+----------------------------------------------+ | integer       | 32 bits unsigned number                      | +---------------+----------------------------------------------+ | signed        | 32 bits signed number                        | +---------------+----------------------------------------------+ | short         | 16 bits unsigned number                      | +---------------+----------------------------------------------+ | byte          | 8 bits unsigned number                       | +---------------+----------------------------------------------+ | tlv           | Nested tag-length-value                      | +---------------+----------------------------------------------+ | integer64     | 64 bits unsigned number                      | +---------------+----------------------------------------------+</p> <p>These datatypes are parsed but not supported:</p> <p>+---------------+----------------------------------------------+ | type          | description                                  | +===============+==============================================+ | ifid          | 8 octets in network byte order               | +---------------+----------------------------------------------+ | ether         | 6 octets of hh:hh:hh:hh:hh:hh                | |               | where 'h' is hex digits, upper or lowercase. | +---------------+----------------------------------------------+</p>"},{"location":"api/dictionary/#pyrad2.dictionary.Attribute","title":"<code>Attribute</code>","text":"<p>Represents a RADIUS attribute.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Attribute name</p> <code>code</code> <code>int</code> <p>RADIUS code</p> <code>type</code> <code>str</code> <p>Data type (e.g., 'string', 'ipaddr')</p> <code>vendor</code> <code>int</code> <p>Vendor ID (0 if standard)</p> <code>has_tag</code> <code>bool</code> <p>Whether attribute supports tags</p> <code>encrypt</code> <code>int</code> <p>Encryption type (0 = none)</p> <code>values</code> <code>BiDict</code> <p>Mapping of named values to their codes</p> Source code in <code>pyrad2/dictionary.py</code> <pre><code>class Attribute:\n    \"\"\"Represents a RADIUS attribute.\n\n    Attributes:\n        name (str): Attribute name\n        code (int): RADIUS code\n        type (str): Data type (e.g., 'string', 'ipaddr')\n        vendor (int): Vendor ID (0 if standard)\n        has_tag (bool): Whether attribute supports tags\n        encrypt (int): Encryption type (0 = none)\n        values (BiDict): Mapping of named values to their codes\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        code: int,\n        datatype: str,\n        is_sub_attribute: bool = False,\n        vendor: str = \"\",\n        values=None,\n        encrypt: int = 0,\n        has_tag: bool = False,\n    ):\n        if datatype not in DATATYPES:\n            raise ValueError(\"Invalid data type\")\n        self.name = name\n        self.code = code\n        self.type = datatype\n        self.vendor = vendor\n        self.encrypt = encrypt\n        self.has_tag = has_tag\n        self.values = bidict.BiDict()\n        self.sub_attributes: dict = {}\n        self.parent = None\n        self.is_sub_attribute = is_sub_attribute\n        if values:\n            for key, value in values.items():\n                self.values.Add(key, value)\n</code></pre>"},{"location":"api/dictionary/#pyrad2.dictionary.Dictionary","title":"<code>Dictionary</code>","text":"<p>RADIUS dictionary class.</p> <p>This class stores all information about vendors, attributes and their values as defined in RADIUS dictionary files.</p> <p>:ivar vendors:    bidict mapping vendor name to vendor code :type vendors:    bidict :ivar attrindex:  bidict mapping :type attrindex:  bidict :ivar attributes: bidict mapping attribute name to attribute class :type attributes: bidict</p> Source code in <code>pyrad2/dictionary.py</code> <pre><code>class Dictionary:\n    \"\"\"RADIUS dictionary class.\n\n    This class stores all information about vendors, attributes and their\n    values as defined in RADIUS dictionary files.\n\n    :ivar vendors:    bidict mapping vendor name to vendor code\n    :type vendors:    bidict\n    :ivar attrindex:  bidict mapping\n    :type attrindex:  bidict\n    :ivar attributes: bidict mapping attribute name to attribute class\n    :type attributes: bidict\n    \"\"\"\n\n    def __init__(self, dict: Optional[str] = None, *dicts):\n        \"\"\"Initialize a new Dictionary instance and load specified dictionary files.\n\n        :param dict:  path of dictionary file or file-like object to read\n        :type dict:   string or file\n        :param dicts: list of dictionaries\n        :type dicts:  sequence of strings or files\n        \"\"\"\n        self.vendors = bidict.BiDict()\n        self.vendors.Add(\"\", 0)\n        self.attrindex = bidict.BiDict()\n        self.attributes: Dict[Hashable, Any] = {}\n        self.defer_parse: list[tuple[Dict, list]] = []\n\n        if dict:\n            self.ReadDictionary(dict)\n\n        for i in dicts:\n            self.ReadDictionary(i)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of attributes defined.\"\"\"\n        return len(self.attributes)\n\n    def __getitem__(self, key: Hashable):\n        \"\"\"Retrieve an Attribute by name.\"\"\"\n        return self.attributes[key]\n\n    def __contains__(self, key: Hashable) -&gt; bool:\n        \"\"\"Check if an attribute is defined in the dictionary.\"\"\"\n        return key in self.attributes\n\n    has_key = __contains__\n\n    def __ParseAttribute(self, state: dict, tokens: list):\n        \"\"\"Parse an ATTRIBUTE line from a dictionary file.\"\"\"\n        if len(tokens) not in [4, 5]:\n            raise ParseError(\n                \"Incorrect number of tokens for attribute definition\",\n                name=state[\"file\"],\n                line=state[\"line\"],\n            )\n\n        vendor = state[\"vendor\"]\n        has_tag = False\n        encrypt = 0\n        if len(tokens) &gt;= 5:\n\n            def keyval(o):\n                kv = o.split(\"=\")\n                if len(kv) == 2:\n                    return (kv[0], kv[1])\n                else:\n                    return (kv[0], None)\n\n            options = [keyval(o) for o in tokens[4].split(\",\")]\n            for key, val in options:\n                if key == \"has_tag\":\n                    has_tag = True\n                elif key == \"encrypt\":\n                    if val not in [\"1\", \"2\", \"3\"]:\n                        raise ParseError(\n                            \"Illegal attribute encryption: %s\" % val,\n                            file=state[\"file\"],\n                            line=state[\"line\"],\n                        )\n                    encrypt = int(val)\n\n            if (not has_tag) and encrypt == 0:\n                vendor = tokens[4]\n                if not self.vendors.HasForward(vendor):\n                    if vendor == \"concat\":\n                        # ignore attributes with concat (freeradius compat.)\n                        return None\n                    else:\n                        raise ParseError(\n                            \"Unknown vendor \" + vendor,\n                            file=state[\"file\"],\n                            line=state[\"line\"],\n                        )\n\n        (attribute, code, datatype) = tokens[1:4]\n\n        codes = code.split(\".\")\n\n        # Codes can be sent as hex, or octal or decimal string representations.\n        tmp = []\n        for c in codes:\n            if c.startswith(\"0x\"):\n                tmp.append(int(c, 16))\n            elif c.startswith(\"0o\"):\n                tmp.append(int(c, 8))\n            else:\n                tmp.append(int(c, 10))\n        codes = tmp\n\n        is_sub_attribute = len(codes) &gt; 1\n        if len(codes) == 2:\n            code = int(codes[1])\n            parent_code = int(codes[0])\n        elif len(codes) == 1:\n            code = int(codes[0])\n            parent_code = None\n        else:\n            raise ParseError(\"nested tlvs are not supported\")\n\n        datatype = datatype.split(\"[\")[0]\n\n        if datatype not in DATATYPES:\n            raise ParseError(\n                \"Illegal type: \" + datatype, file=state[\"file\"], line=state[\"line\"]\n            )\n        if vendor:\n            if is_sub_attribute:\n                key = (self.vendors.GetForward(vendor), parent_code, code)\n            else:\n                key = (self.vendors.GetForward(vendor), code)\n        else:\n            if is_sub_attribute:\n                key = (parent_code, code)\n            else:\n                key = code\n\n        self.attrindex.Add(attribute, key)\n        self.attributes[attribute] = Attribute(\n            attribute,\n            code,\n            datatype,\n            is_sub_attribute,\n            vendor,\n            encrypt=encrypt,\n            has_tag=has_tag,\n        )\n        if datatype == \"tlv\":\n            # save attribute in tlvs\n            state[\"tlvs\"][code] = self.attributes[attribute]\n        if is_sub_attribute:\n            # save sub attribute in parent tlv and update their parent field\n            state[\"tlvs\"][parent_code].sub_attributes[code] = attribute\n            self.attributes[attribute].parent = state[\"tlvs\"][parent_code]\n\n    def __ParseValue(self, state: dict, tokens: list, defer: bool) -&gt; None:\n        \"\"\"Parse a VALUE line from a dictionary file.\"\"\"\n        if len(tokens) != 4:\n            raise ParseError(\n                \"Incorrect number of tokens for value definition\",\n                file=state[\"file\"],\n                line=state[\"line\"],\n            )\n\n        (attr, key, value) = tokens[1:]\n\n        try:\n            adef = self.attributes[attr]\n        except KeyError:\n            if defer:\n                self.defer_parse.append((copy(state), copy(tokens)))\n                return\n            raise ParseError(\n                \"Value defined for unknown attribute \" + attr,\n                file=state[\"file\"],\n                line=state[\"line\"],\n            )\n\n        if adef.type in [\"integer\", \"signed\", \"short\", \"byte\", \"integer64\"]:\n            value = int(value, 0)\n        value = tools.EncodeAttr(adef.type, value)\n        self.attributes[attr].values.Add(key, value)\n\n    def __ParseVendor(self, state: dict, tokens: list) -&gt; None:\n        \"\"\"Parse a VENDOR line, registering a new vendor.\"\"\"\n        if len(tokens) not in [3, 4]:\n            raise ParseError(\n                \"Incorrect number of tokens for vendor definition\",\n                file=state[\"file\"],\n                line=state[\"line\"],\n            )\n\n        # Parse format specification, but do\n        # nothing about it for now\n        if len(tokens) == 4:\n            fmt = tokens[3].split(\"=\")\n            if fmt[0] != \"format\":\n                raise ParseError(\n                    \"Unknown option '%s' for vendor definition\" % (fmt[0]),\n                    file=state[\"file\"],\n                    line=state[\"line\"],\n                )\n            try:\n                (_type, length) = tuple(int(a) for a in fmt[1].split(\",\"))\n                if _type not in [1, 2, 4] or length not in [0, 1, 2]:\n                    raise ParseError(\n                        \"Unknown vendor format specification %s\" % (fmt[1]),\n                        file=state[\"file\"],\n                        line=state[\"line\"],\n                    )\n            except ValueError:\n                raise ParseError(\n                    \"Syntax error in vendor specification\",\n                    file=state[\"file\"],\n                    line=state[\"line\"],\n                )\n\n        (vendorname, vendor) = tokens[1:3]\n        self.vendors.Add(vendorname, int(vendor, 0))\n\n    def __ParseBeginVendor(self, state: dict, tokens: list) -&gt; None:\n        \"\"\"Start a block of attributes for a specific vendor.\"\"\"\n        if len(tokens) != 2:\n            raise ParseError(\n                \"Incorrect number of tokens for begin-vendor statement\",\n                file=state[\"file\"],\n                line=state[\"line\"],\n            )\n\n        vendor = tokens[1]\n\n        if not self.vendors.HasForward(vendor):\n            raise ParseError(\n                \"Unknown vendor %s in begin-vendor statement\" % vendor,\n                file=state[\"file\"],\n                line=state[\"line\"],\n            )\n\n        state[\"vendor\"] = vendor\n\n    def __ParseEndVendor(self, state: dict, tokens: list):\n        \"\"\"End a block of vendor-specific attributes.\"\"\"\n        if len(tokens) != 2:\n            raise ParseError(\n                \"Incorrect number of tokens for end-vendor statement\",\n                file=state[\"file\"],\n                line=state[\"line\"],\n            )\n\n        vendor = tokens[1]\n\n        if state[\"vendor\"] != vendor:\n            raise ParseError(\n                \"Ending non-open vendor\" + vendor,\n                file=state[\"file\"],\n                line=state[\"line\"],\n            )\n        state[\"vendor\"] = \"\"\n\n    def ReadDictionary(self, file: str) -&gt; None:\n        \"\"\"Parse a dictionary file.\n        Reads a RADIUS dictionary file and merges its contents into the\n        class instance.\n\n        :param file: Name of dictionary file to parse or a file-like object\n        :type file:  string or file-like object\n        \"\"\"\n\n        fil = dictfile.DictFile(file)\n\n        state: Dict[str, Any] = {}\n        state[\"vendor\"] = \"\"\n        state[\"tlvs\"] = {}\n        self.defer_parse = []\n        for line in fil:\n            state[\"file\"] = fil.File()\n            state[\"line\"] = fil.Line()\n            line = line.split(\"#\", 1)[0].strip()\n\n            tokens = line.split()\n            if not tokens:\n                continue\n\n            key = tokens[0].upper()\n            if key == \"ATTRIBUTE\":\n                self.__ParseAttribute(state, tokens)\n            elif key == \"VALUE\":\n                self.__ParseValue(state, tokens, True)\n            elif key == \"VENDOR\":\n                self.__ParseVendor(state, tokens)\n            elif key == \"BEGIN-VENDOR\":\n                self.__ParseBeginVendor(state, tokens)\n            elif key == \"END-VENDOR\":\n                self.__ParseEndVendor(state, tokens)\n\n        for state, tokens in self.defer_parse:\n            key = tokens[0].upper()\n            if key == \"VALUE\":\n                self.__ParseValue(state, tokens, False)\n        self.defer_parse = []\n</code></pre>"},{"location":"api/dictionary/#pyrad2.dictionary.Dictionary.ReadDictionary","title":"<code>ReadDictionary(file)</code>","text":"<p>Parse a dictionary file. Reads a RADIUS dictionary file and merges its contents into the class instance.</p> <p>:param file: Name of dictionary file to parse or a file-like object :type file:  string or file-like object</p> Source code in <code>pyrad2/dictionary.py</code> <pre><code>def ReadDictionary(self, file: str) -&gt; None:\n    \"\"\"Parse a dictionary file.\n    Reads a RADIUS dictionary file and merges its contents into the\n    class instance.\n\n    :param file: Name of dictionary file to parse or a file-like object\n    :type file:  string or file-like object\n    \"\"\"\n\n    fil = dictfile.DictFile(file)\n\n    state: Dict[str, Any] = {}\n    state[\"vendor\"] = \"\"\n    state[\"tlvs\"] = {}\n    self.defer_parse = []\n    for line in fil:\n        state[\"file\"] = fil.File()\n        state[\"line\"] = fil.Line()\n        line = line.split(\"#\", 1)[0].strip()\n\n        tokens = line.split()\n        if not tokens:\n            continue\n\n        key = tokens[0].upper()\n        if key == \"ATTRIBUTE\":\n            self.__ParseAttribute(state, tokens)\n        elif key == \"VALUE\":\n            self.__ParseValue(state, tokens, True)\n        elif key == \"VENDOR\":\n            self.__ParseVendor(state, tokens)\n        elif key == \"BEGIN-VENDOR\":\n            self.__ParseBeginVendor(state, tokens)\n        elif key == \"END-VENDOR\":\n            self.__ParseEndVendor(state, tokens)\n\n    for state, tokens in self.defer_parse:\n        key = tokens[0].upper()\n        if key == \"VALUE\":\n            self.__ParseValue(state, tokens, False)\n    self.defer_parse = []\n</code></pre>"},{"location":"api/dictionary/#pyrad2.dictionary.Dictionary.__ParseAttribute","title":"<code>__ParseAttribute(state, tokens)</code>","text":"<p>Parse an ATTRIBUTE line from a dictionary file.</p> Source code in <code>pyrad2/dictionary.py</code> <pre><code>def __ParseAttribute(self, state: dict, tokens: list):\n    \"\"\"Parse an ATTRIBUTE line from a dictionary file.\"\"\"\n    if len(tokens) not in [4, 5]:\n        raise ParseError(\n            \"Incorrect number of tokens for attribute definition\",\n            name=state[\"file\"],\n            line=state[\"line\"],\n        )\n\n    vendor = state[\"vendor\"]\n    has_tag = False\n    encrypt = 0\n    if len(tokens) &gt;= 5:\n\n        def keyval(o):\n            kv = o.split(\"=\")\n            if len(kv) == 2:\n                return (kv[0], kv[1])\n            else:\n                return (kv[0], None)\n\n        options = [keyval(o) for o in tokens[4].split(\",\")]\n        for key, val in options:\n            if key == \"has_tag\":\n                has_tag = True\n            elif key == \"encrypt\":\n                if val not in [\"1\", \"2\", \"3\"]:\n                    raise ParseError(\n                        \"Illegal attribute encryption: %s\" % val,\n                        file=state[\"file\"],\n                        line=state[\"line\"],\n                    )\n                encrypt = int(val)\n\n        if (not has_tag) and encrypt == 0:\n            vendor = tokens[4]\n            if not self.vendors.HasForward(vendor):\n                if vendor == \"concat\":\n                    # ignore attributes with concat (freeradius compat.)\n                    return None\n                else:\n                    raise ParseError(\n                        \"Unknown vendor \" + vendor,\n                        file=state[\"file\"],\n                        line=state[\"line\"],\n                    )\n\n    (attribute, code, datatype) = tokens[1:4]\n\n    codes = code.split(\".\")\n\n    # Codes can be sent as hex, or octal or decimal string representations.\n    tmp = []\n    for c in codes:\n        if c.startswith(\"0x\"):\n            tmp.append(int(c, 16))\n        elif c.startswith(\"0o\"):\n            tmp.append(int(c, 8))\n        else:\n            tmp.append(int(c, 10))\n    codes = tmp\n\n    is_sub_attribute = len(codes) &gt; 1\n    if len(codes) == 2:\n        code = int(codes[1])\n        parent_code = int(codes[0])\n    elif len(codes) == 1:\n        code = int(codes[0])\n        parent_code = None\n    else:\n        raise ParseError(\"nested tlvs are not supported\")\n\n    datatype = datatype.split(\"[\")[0]\n\n    if datatype not in DATATYPES:\n        raise ParseError(\n            \"Illegal type: \" + datatype, file=state[\"file\"], line=state[\"line\"]\n        )\n    if vendor:\n        if is_sub_attribute:\n            key = (self.vendors.GetForward(vendor), parent_code, code)\n        else:\n            key = (self.vendors.GetForward(vendor), code)\n    else:\n        if is_sub_attribute:\n            key = (parent_code, code)\n        else:\n            key = code\n\n    self.attrindex.Add(attribute, key)\n    self.attributes[attribute] = Attribute(\n        attribute,\n        code,\n        datatype,\n        is_sub_attribute,\n        vendor,\n        encrypt=encrypt,\n        has_tag=has_tag,\n    )\n    if datatype == \"tlv\":\n        # save attribute in tlvs\n        state[\"tlvs\"][code] = self.attributes[attribute]\n    if is_sub_attribute:\n        # save sub attribute in parent tlv and update their parent field\n        state[\"tlvs\"][parent_code].sub_attributes[code] = attribute\n        self.attributes[attribute].parent = state[\"tlvs\"][parent_code]\n</code></pre>"},{"location":"api/dictionary/#pyrad2.dictionary.Dictionary.__ParseBeginVendor","title":"<code>__ParseBeginVendor(state, tokens)</code>","text":"<p>Start a block of attributes for a specific vendor.</p> Source code in <code>pyrad2/dictionary.py</code> <pre><code>def __ParseBeginVendor(self, state: dict, tokens: list) -&gt; None:\n    \"\"\"Start a block of attributes for a specific vendor.\"\"\"\n    if len(tokens) != 2:\n        raise ParseError(\n            \"Incorrect number of tokens for begin-vendor statement\",\n            file=state[\"file\"],\n            line=state[\"line\"],\n        )\n\n    vendor = tokens[1]\n\n    if not self.vendors.HasForward(vendor):\n        raise ParseError(\n            \"Unknown vendor %s in begin-vendor statement\" % vendor,\n            file=state[\"file\"],\n            line=state[\"line\"],\n        )\n\n    state[\"vendor\"] = vendor\n</code></pre>"},{"location":"api/dictionary/#pyrad2.dictionary.Dictionary.__ParseEndVendor","title":"<code>__ParseEndVendor(state, tokens)</code>","text":"<p>End a block of vendor-specific attributes.</p> Source code in <code>pyrad2/dictionary.py</code> <pre><code>def __ParseEndVendor(self, state: dict, tokens: list):\n    \"\"\"End a block of vendor-specific attributes.\"\"\"\n    if len(tokens) != 2:\n        raise ParseError(\n            \"Incorrect number of tokens for end-vendor statement\",\n            file=state[\"file\"],\n            line=state[\"line\"],\n        )\n\n    vendor = tokens[1]\n\n    if state[\"vendor\"] != vendor:\n        raise ParseError(\n            \"Ending non-open vendor\" + vendor,\n            file=state[\"file\"],\n            line=state[\"line\"],\n        )\n    state[\"vendor\"] = \"\"\n</code></pre>"},{"location":"api/dictionary/#pyrad2.dictionary.Dictionary.__ParseValue","title":"<code>__ParseValue(state, tokens, defer)</code>","text":"<p>Parse a VALUE line from a dictionary file.</p> Source code in <code>pyrad2/dictionary.py</code> <pre><code>def __ParseValue(self, state: dict, tokens: list, defer: bool) -&gt; None:\n    \"\"\"Parse a VALUE line from a dictionary file.\"\"\"\n    if len(tokens) != 4:\n        raise ParseError(\n            \"Incorrect number of tokens for value definition\",\n            file=state[\"file\"],\n            line=state[\"line\"],\n        )\n\n    (attr, key, value) = tokens[1:]\n\n    try:\n        adef = self.attributes[attr]\n    except KeyError:\n        if defer:\n            self.defer_parse.append((copy(state), copy(tokens)))\n            return\n        raise ParseError(\n            \"Value defined for unknown attribute \" + attr,\n            file=state[\"file\"],\n            line=state[\"line\"],\n        )\n\n    if adef.type in [\"integer\", \"signed\", \"short\", \"byte\", \"integer64\"]:\n        value = int(value, 0)\n    value = tools.EncodeAttr(adef.type, value)\n    self.attributes[attr].values.Add(key, value)\n</code></pre>"},{"location":"api/dictionary/#pyrad2.dictionary.Dictionary.__ParseVendor","title":"<code>__ParseVendor(state, tokens)</code>","text":"<p>Parse a VENDOR line, registering a new vendor.</p> Source code in <code>pyrad2/dictionary.py</code> <pre><code>def __ParseVendor(self, state: dict, tokens: list) -&gt; None:\n    \"\"\"Parse a VENDOR line, registering a new vendor.\"\"\"\n    if len(tokens) not in [3, 4]:\n        raise ParseError(\n            \"Incorrect number of tokens for vendor definition\",\n            file=state[\"file\"],\n            line=state[\"line\"],\n        )\n\n    # Parse format specification, but do\n    # nothing about it for now\n    if len(tokens) == 4:\n        fmt = tokens[3].split(\"=\")\n        if fmt[0] != \"format\":\n            raise ParseError(\n                \"Unknown option '%s' for vendor definition\" % (fmt[0]),\n                file=state[\"file\"],\n                line=state[\"line\"],\n            )\n        try:\n            (_type, length) = tuple(int(a) for a in fmt[1].split(\",\"))\n            if _type not in [1, 2, 4] or length not in [0, 1, 2]:\n                raise ParseError(\n                    \"Unknown vendor format specification %s\" % (fmt[1]),\n                    file=state[\"file\"],\n                    line=state[\"line\"],\n                )\n        except ValueError:\n            raise ParseError(\n                \"Syntax error in vendor specification\",\n                file=state[\"file\"],\n                line=state[\"line\"],\n            )\n\n    (vendorname, vendor) = tokens[1:3]\n    self.vendors.Add(vendorname, int(vendor, 0))\n</code></pre>"},{"location":"api/dictionary/#pyrad2.dictionary.Dictionary.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Check if an attribute is defined in the dictionary.</p> Source code in <code>pyrad2/dictionary.py</code> <pre><code>def __contains__(self, key: Hashable) -&gt; bool:\n    \"\"\"Check if an attribute is defined in the dictionary.\"\"\"\n    return key in self.attributes\n</code></pre>"},{"location":"api/dictionary/#pyrad2.dictionary.Dictionary.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Retrieve an Attribute by name.</p> Source code in <code>pyrad2/dictionary.py</code> <pre><code>def __getitem__(self, key: Hashable):\n    \"\"\"Retrieve an Attribute by name.\"\"\"\n    return self.attributes[key]\n</code></pre>"},{"location":"api/dictionary/#pyrad2.dictionary.Dictionary.__init__","title":"<code>__init__(dict=None, *dicts)</code>","text":"<p>Initialize a new Dictionary instance and load specified dictionary files.</p> <p>:param dict:  path of dictionary file or file-like object to read :type dict:   string or file :param dicts: list of dictionaries :type dicts:  sequence of strings or files</p> Source code in <code>pyrad2/dictionary.py</code> <pre><code>def __init__(self, dict: Optional[str] = None, *dicts):\n    \"\"\"Initialize a new Dictionary instance and load specified dictionary files.\n\n    :param dict:  path of dictionary file or file-like object to read\n    :type dict:   string or file\n    :param dicts: list of dictionaries\n    :type dicts:  sequence of strings or files\n    \"\"\"\n    self.vendors = bidict.BiDict()\n    self.vendors.Add(\"\", 0)\n    self.attrindex = bidict.BiDict()\n    self.attributes: Dict[Hashable, Any] = {}\n    self.defer_parse: list[tuple[Dict, list]] = []\n\n    if dict:\n        self.ReadDictionary(dict)\n\n    for i in dicts:\n        self.ReadDictionary(i)\n</code></pre>"},{"location":"api/dictionary/#pyrad2.dictionary.Dictionary.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of attributes defined.</p> Source code in <code>pyrad2/dictionary.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of attributes defined.\"\"\"\n    return len(self.attributes)\n</code></pre>"},{"location":"api/dictionary/#pyrad2.dictionary.ParseError","title":"<code>ParseError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised for errors while parsing RADIUS dictionary files.</p> <p>:ivar msg:        Error message :type msg:        string :ivar linenumber: Line number on which the error occurred :type linenumber: integer</p> Source code in <code>pyrad2/dictionary.py</code> <pre><code>class ParseError(Exception):\n    \"\"\"Exception raised for errors\n    while parsing RADIUS dictionary files.\n\n\n    :ivar msg:        Error message\n    :type msg:        string\n    :ivar linenumber: Line number on which the error occurred\n    :type linenumber: integer\n    \"\"\"\n\n    def __init__(self, msg=None, **data):\n        self.msg = msg\n        self.file = data.get(\"file\", \"\")\n        self.line = data.get(\"line\", -1)\n\n    def __str__(self):\n        str = \"\"\n        if self.file:\n            str += self.file\n        if self.line &gt; -1:\n            str += \"(%d)\" % self.line\n        if self.file or self.line &gt; -1:\n            str += \": \"\n        str += \"Parse error\"\n        if self.msg:\n            str += \": %s\" % self.msg\n\n        return str\n</code></pre>"},{"location":"api/host/","title":"Host","text":""},{"location":"api/host/#pyrad2.host.Host","title":"<code>Host</code>","text":"<p>Generic RADIUS capable host.</p> <p>:ivar     dict: RADIUS dictionary :type     dict: pyrad2.dictionary.Dictionary :ivar authport: port to listen on for authentication packets :type authport: integer :ivar acctport: port to listen on for accounting packets :type acctport: integer</p> Source code in <code>pyrad2/host.py</code> <pre><code>class Host:\n    \"\"\"Generic RADIUS capable host.\n\n    :ivar     dict: RADIUS dictionary\n    :type     dict: pyrad2.dictionary.Dictionary\n    :ivar authport: port to listen on for authentication packets\n    :type authport: integer\n    :ivar acctport: port to listen on for accounting packets\n    :type acctport: integer\n    \"\"\"\n\n    def __init__(self, authport=1812, acctport=1813, coaport=3799, dict=None):\n        \"\"\"Constructor\n\n        :param authport: port to listen on for authentication packets\n        :type  authport: integer\n        :param acctport: port to listen on for accounting packets\n        :type  acctport: integer\n        :param coaport: port to listen on for CoA packets\n        :type  coaport: integer\n        :param     dict: RADIUS dictionary\n        :type      dict: pyrad2.dictionary.Dictionary\n        \"\"\"\n        self.dict = dict\n        self.authport = authport\n        self.acctport = acctport\n        self.coaport = coaport\n\n    def CreatePacket(self, **args):\n        \"\"\"Create a new RADIUS packet.\n        This utility function creates a new RADIUS authentication\n        packet which can be used to communicate with the RADIUS server\n        this client talks to. This is initializing the new packet with\n        the dictionary and secret used for the client.\n\n        :return: a new empty packet instance\n        :rtype:  pyrad2.packet.Packet\n        \"\"\"\n        return packet.Packet(dict=self.dict, **args)\n\n    def CreateAuthPacket(self, **args):\n        \"\"\"Create a new authentication RADIUS packet.\n        This utility function creates a new RADIUS authentication\n        packet which can be used to communicate with the RADIUS server\n        this client talks to. This is initializing the new packet with\n        the dictionary and secret used for the client.\n\n        :return: a new empty packet instance\n        :rtype:  pyrad2.packet.AuthPacket\n        \"\"\"\n        return packet.AuthPacket(dict=self.dict, **args)\n\n    def CreateAcctPacket(self, **args):\n        \"\"\"Create a new accounting RADIUS packet.\n        This utility function creates a new accounting RADIUS packet\n        which can be used to communicate with the RADIUS server this\n        client talks to. This is initializing the new packet with the\n        dictionary and secret used for the client.\n\n        :return: a new empty packet instance\n        :rtype:  pyrad2.packet.AcctPacket\n        \"\"\"\n        return packet.AcctPacket(dict=self.dict, **args)\n\n    def CreateCoAPacket(self, **args):\n        \"\"\"Create a new CoA RADIUS packet.\n        This utility function creates a new CoA RADIUS packet\n        which can be used to communicate with the RADIUS server this\n        client talks to. This is initializing the new packet with the\n        dictionary and secret used for the client.\n\n        :return: a new empty packet instance\n        :rtype:  pyrad2.packet.CoAPacket\n        \"\"\"\n        return packet.CoAPacket(dict=self.dict, **args)\n\n    def SendPacket(self, fd, pkt):\n        \"\"\"Send a packet.\n\n        :param fd: socket to send packet with\n        :type  fd: socket class instance\n        :param pkt: packet to send\n        :type  pkt: Packet class instance\n        \"\"\"\n        fd.sendto(pkt.Packet(), pkt.source)\n\n    def SendReplyPacket(self, fd, pkt):\n        \"\"\"Send a packet.\n\n        :param fd: socket to send packet with\n        :type  fd: socket class instance\n        :param pkt: packet to send\n        :type  pkt: Packet class instance\n        \"\"\"\n        fd.sendto(pkt.ReplyPacket(), pkt.source)\n</code></pre>"},{"location":"api/host/#pyrad2.host.Host.CreateAcctPacket","title":"<code>CreateAcctPacket(**args)</code>","text":"<p>Create a new accounting RADIUS packet. This utility function creates a new accounting RADIUS packet which can be used to communicate with the RADIUS server this client talks to. This is initializing the new packet with the dictionary and secret used for the client.</p> <p>:return: a new empty packet instance :rtype:  pyrad2.packet.AcctPacket</p> Source code in <code>pyrad2/host.py</code> <pre><code>def CreateAcctPacket(self, **args):\n    \"\"\"Create a new accounting RADIUS packet.\n    This utility function creates a new accounting RADIUS packet\n    which can be used to communicate with the RADIUS server this\n    client talks to. This is initializing the new packet with the\n    dictionary and secret used for the client.\n\n    :return: a new empty packet instance\n    :rtype:  pyrad2.packet.AcctPacket\n    \"\"\"\n    return packet.AcctPacket(dict=self.dict, **args)\n</code></pre>"},{"location":"api/host/#pyrad2.host.Host.CreateAuthPacket","title":"<code>CreateAuthPacket(**args)</code>","text":"<p>Create a new authentication RADIUS packet. This utility function creates a new RADIUS authentication packet which can be used to communicate with the RADIUS server this client talks to. This is initializing the new packet with the dictionary and secret used for the client.</p> <p>:return: a new empty packet instance :rtype:  pyrad2.packet.AuthPacket</p> Source code in <code>pyrad2/host.py</code> <pre><code>def CreateAuthPacket(self, **args):\n    \"\"\"Create a new authentication RADIUS packet.\n    This utility function creates a new RADIUS authentication\n    packet which can be used to communicate with the RADIUS server\n    this client talks to. This is initializing the new packet with\n    the dictionary and secret used for the client.\n\n    :return: a new empty packet instance\n    :rtype:  pyrad2.packet.AuthPacket\n    \"\"\"\n    return packet.AuthPacket(dict=self.dict, **args)\n</code></pre>"},{"location":"api/host/#pyrad2.host.Host.CreateCoAPacket","title":"<code>CreateCoAPacket(**args)</code>","text":"<p>Create a new CoA RADIUS packet. This utility function creates a new CoA RADIUS packet which can be used to communicate with the RADIUS server this client talks to. This is initializing the new packet with the dictionary and secret used for the client.</p> <p>:return: a new empty packet instance :rtype:  pyrad2.packet.CoAPacket</p> Source code in <code>pyrad2/host.py</code> <pre><code>def CreateCoAPacket(self, **args):\n    \"\"\"Create a new CoA RADIUS packet.\n    This utility function creates a new CoA RADIUS packet\n    which can be used to communicate with the RADIUS server this\n    client talks to. This is initializing the new packet with the\n    dictionary and secret used for the client.\n\n    :return: a new empty packet instance\n    :rtype:  pyrad2.packet.CoAPacket\n    \"\"\"\n    return packet.CoAPacket(dict=self.dict, **args)\n</code></pre>"},{"location":"api/host/#pyrad2.host.Host.CreatePacket","title":"<code>CreatePacket(**args)</code>","text":"<p>Create a new RADIUS packet. This utility function creates a new RADIUS authentication packet which can be used to communicate with the RADIUS server this client talks to. This is initializing the new packet with the dictionary and secret used for the client.</p> <p>:return: a new empty packet instance :rtype:  pyrad2.packet.Packet</p> Source code in <code>pyrad2/host.py</code> <pre><code>def CreatePacket(self, **args):\n    \"\"\"Create a new RADIUS packet.\n    This utility function creates a new RADIUS authentication\n    packet which can be used to communicate with the RADIUS server\n    this client talks to. This is initializing the new packet with\n    the dictionary and secret used for the client.\n\n    :return: a new empty packet instance\n    :rtype:  pyrad2.packet.Packet\n    \"\"\"\n    return packet.Packet(dict=self.dict, **args)\n</code></pre>"},{"location":"api/host/#pyrad2.host.Host.SendPacket","title":"<code>SendPacket(fd, pkt)</code>","text":"<p>Send a packet.</p> <p>:param fd: socket to send packet with :type  fd: socket class instance :param pkt: packet to send :type  pkt: Packet class instance</p> Source code in <code>pyrad2/host.py</code> <pre><code>def SendPacket(self, fd, pkt):\n    \"\"\"Send a packet.\n\n    :param fd: socket to send packet with\n    :type  fd: socket class instance\n    :param pkt: packet to send\n    :type  pkt: Packet class instance\n    \"\"\"\n    fd.sendto(pkt.Packet(), pkt.source)\n</code></pre>"},{"location":"api/host/#pyrad2.host.Host.SendReplyPacket","title":"<code>SendReplyPacket(fd, pkt)</code>","text":"<p>Send a packet.</p> <p>:param fd: socket to send packet with :type  fd: socket class instance :param pkt: packet to send :type  pkt: Packet class instance</p> Source code in <code>pyrad2/host.py</code> <pre><code>def SendReplyPacket(self, fd, pkt):\n    \"\"\"Send a packet.\n\n    :param fd: socket to send packet with\n    :type  fd: socket class instance\n    :param pkt: packet to send\n    :type  pkt: Packet class instance\n    \"\"\"\n    fd.sendto(pkt.ReplyPacket(), pkt.source)\n</code></pre>"},{"location":"api/host/#pyrad2.host.Host.__init__","title":"<code>__init__(authport=1812, acctport=1813, coaport=3799, dict=None)</code>","text":"<p>Constructor</p> <p>:param authport: port to listen on for authentication packets :type  authport: integer :param acctport: port to listen on for accounting packets :type  acctport: integer :param coaport: port to listen on for CoA packets :type  coaport: integer :param     dict: RADIUS dictionary :type      dict: pyrad2.dictionary.Dictionary</p> Source code in <code>pyrad2/host.py</code> <pre><code>def __init__(self, authport=1812, acctport=1813, coaport=3799, dict=None):\n    \"\"\"Constructor\n\n    :param authport: port to listen on for authentication packets\n    :type  authport: integer\n    :param acctport: port to listen on for accounting packets\n    :type  acctport: integer\n    :param coaport: port to listen on for CoA packets\n    :type  coaport: integer\n    :param     dict: RADIUS dictionary\n    :type      dict: pyrad2.dictionary.Dictionary\n    \"\"\"\n    self.dict = dict\n    self.authport = authport\n    self.acctport = acctport\n    self.coaport = coaport\n</code></pre>"},{"location":"api/packet/","title":"packet","text":""},{"location":"api/packet/#pyrad2.packet.AcctPacket","title":"<code>AcctPacket</code>","text":"<p>               Bases: <code>Packet</code></p> <p>RADIUS accounting packets. This class is a specialization of the generic :obj:<code>Packet</code> class for accounting packets.</p> Source code in <code>pyrad2/packet.py</code> <pre><code>class AcctPacket(Packet):\n    \"\"\"RADIUS accounting packets. This class is a specialization\n    of the generic :obj:`Packet` class for accounting packets.\n    \"\"\"\n\n    def __init__(\n        self,\n        code: int = AccountingRequest,\n        id: Optional[int] = None,\n        secret: bytes = b\"\",\n        authenticator: Optional[bytes] = None,\n        **attributes,\n    ):\n        \"\"\"Constructor\n\n        :param dict:   RADIUS dictionary\n        :type dict:    pyrad2.dictionary.Dictionary class\n        :param secret: secret needed to communicate with a RADIUS server\n        :type secret:  string\n        :param id:     packet identification number\n        :type id:      integer (8 bits)\n        :param code:   packet type code\n        :type code:    integer (8bits)\n        :param packet: raw packet to decode\n        :type packet:  string\n        \"\"\"\n        super().__init__(code, id, secret, authenticator, **attributes)\n\n    def CreateReply(self, **attributes) -&gt; \"AcctPacket\":\n        \"\"\"Create a new packet as a reply to this one. This method\n        makes sure the authenticator and secret are copied over\n        to the new instance.\n        \"\"\"\n        return AcctPacket(\n            AccountingResponse,\n            self.id,\n            self.secret,\n            self.authenticator,\n            dict=self.dict,\n            **attributes,\n        )\n\n    def VerifyAcctRequest(self) -&gt; bool:\n        \"\"\"Verify request authenticator.\n\n        :return: True if verification passed else False\n        :rtype: boolean\n        \"\"\"\n        return self.VerifyPacket()\n\n    def RequestPacket(self) -&gt; bytes:\n        \"\"\"Create a ready-to-transmit authentication request packet.\n        Return a RADIUS packet which can be directly transmitted\n        to a RADIUS server.\n\n        :return: raw packet\n        :rtype:  string\n        \"\"\"\n\n        if self.id is None:\n            self.id = self.CreateID()\n\n        if self.message_authenticator:\n            self._refresh_message_authenticator()\n\n        attr = self._PktEncodeAttributes()\n        header = struct.pack(\"!BBH\", self.code, self.id, (20 + len(attr)))\n        self.authenticator = hashlib.md5(\n            header[0:4] + 16 * b\"\\x00\" + attr + self.secret\n        ).digest()\n\n        ans = header + self.authenticator + attr\n\n        return ans\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.AcctPacket.CreateReply","title":"<code>CreateReply(**attributes)</code>","text":"<p>Create a new packet as a reply to this one. This method makes sure the authenticator and secret are copied over to the new instance.</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def CreateReply(self, **attributes) -&gt; \"AcctPacket\":\n    \"\"\"Create a new packet as a reply to this one. This method\n    makes sure the authenticator and secret are copied over\n    to the new instance.\n    \"\"\"\n    return AcctPacket(\n        AccountingResponse,\n        self.id,\n        self.secret,\n        self.authenticator,\n        dict=self.dict,\n        **attributes,\n    )\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.AcctPacket.RequestPacket","title":"<code>RequestPacket()</code>","text":"<p>Create a ready-to-transmit authentication request packet. Return a RADIUS packet which can be directly transmitted to a RADIUS server.</p> <p>:return: raw packet :rtype:  string</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def RequestPacket(self) -&gt; bytes:\n    \"\"\"Create a ready-to-transmit authentication request packet.\n    Return a RADIUS packet which can be directly transmitted\n    to a RADIUS server.\n\n    :return: raw packet\n    :rtype:  string\n    \"\"\"\n\n    if self.id is None:\n        self.id = self.CreateID()\n\n    if self.message_authenticator:\n        self._refresh_message_authenticator()\n\n    attr = self._PktEncodeAttributes()\n    header = struct.pack(\"!BBH\", self.code, self.id, (20 + len(attr)))\n    self.authenticator = hashlib.md5(\n        header[0:4] + 16 * b\"\\x00\" + attr + self.secret\n    ).digest()\n\n    ans = header + self.authenticator + attr\n\n    return ans\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.AcctPacket.VerifyAcctRequest","title":"<code>VerifyAcctRequest()</code>","text":"<p>Verify request authenticator.</p> <p>:return: True if verification passed else False :rtype: boolean</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def VerifyAcctRequest(self) -&gt; bool:\n    \"\"\"Verify request authenticator.\n\n    :return: True if verification passed else False\n    :rtype: boolean\n    \"\"\"\n    return self.VerifyPacket()\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.AcctPacket.__init__","title":"<code>__init__(code=AccountingRequest, id=None, secret=b'', authenticator=None, **attributes)</code>","text":"<p>Constructor</p> <p>:param dict:   RADIUS dictionary :type dict:    pyrad2.dictionary.Dictionary class :param secret: secret needed to communicate with a RADIUS server :type secret:  string :param id:     packet identification number :type id:      integer (8 bits) :param code:   packet type code :type code:    integer (8bits) :param packet: raw packet to decode :type packet:  string</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def __init__(\n    self,\n    code: int = AccountingRequest,\n    id: Optional[int] = None,\n    secret: bytes = b\"\",\n    authenticator: Optional[bytes] = None,\n    **attributes,\n):\n    \"\"\"Constructor\n\n    :param dict:   RADIUS dictionary\n    :type dict:    pyrad2.dictionary.Dictionary class\n    :param secret: secret needed to communicate with a RADIUS server\n    :type secret:  string\n    :param id:     packet identification number\n    :type id:      integer (8 bits)\n    :param code:   packet type code\n    :type code:    integer (8bits)\n    :param packet: raw packet to decode\n    :type packet:  string\n    \"\"\"\n    super().__init__(code, id, secret, authenticator, **attributes)\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.AuthPacket","title":"<code>AuthPacket</code>","text":"<p>               Bases: <code>Packet</code></p> Source code in <code>pyrad2/packet.py</code> <pre><code>class AuthPacket(Packet):\n    def __init__(\n        self,\n        code=AccessRequest,\n        id=None,\n        secret=b\"\",\n        authenticator=None,\n        auth_type=\"pap\",\n        **attributes,\n    ):\n        \"\"\"Constructor\n\n        :param code:   packet type code\n        :type code:    integer (8bits)\n        :param id:     packet identification number\n        :type id:      integer (8 bits)\n        :param secret: secret needed to communicate with a RADIUS server\n        :type secret:  string\n\n        :param dict:   RADIUS dictionary\n        :type dict:    pyrad2.dictionary.Dictionary class\n\n        :param packet: raw packet to decode\n        :type packet:  string\n        \"\"\"\n        super().__init__(code, id, secret, authenticator, **attributes)\n        self.auth_type = auth_type\n\n    def CreateReply(self, **attributes):\n        \"\"\"Create a new packet as a reply to this one. This method\n        makes sure the authenticator and secret are copied over\n        to the new instance.\n        \"\"\"\n        return AuthPacket(\n            AccessAccept,\n            self.id,\n            self.secret,\n            self.authenticator,\n            dict=self.dict,\n            auth_type=self.auth_type,\n            **attributes,\n        )\n\n    def RequestPacket(self):\n        \"\"\"Create a ready-to-transmit authentication request packet.\n        Return a RADIUS packet which can be directly transmitted\n        to a RADIUS server.\n\n        :return: raw packet\n        :rtype:  string\n        \"\"\"\n        if self.authenticator is None:\n            self.authenticator = self.CreateAuthenticator()\n\n        if self.id is None:\n            self.id = self.CreateID()\n\n        if self.message_authenticator:\n            self._refresh_message_authenticator()\n\n        attr = self._PktEncodeAttributes()\n        if self.auth_type == \"eap-md5\":\n            header = struct.pack(\n                \"!BBH16s\", self.code, self.id, (20 + 18 + len(attr)), self.authenticator\n            )\n            digest = hmac_new(\n                self.secret,\n                header\n                + attr\n                + struct.pack(\"!BB16s\", 80, struct.calcsize(\"!BB16s\"), b\"\"),\n            ).digest()\n            return (\n                header\n                + attr\n                + struct.pack(\"!BB16s\", 80, struct.calcsize(\"!BB16s\"), digest)\n            )\n\n        header = struct.pack(\n            \"!BBH16s\", self.code, self.id, (20 + len(attr)), self.authenticator\n        )\n\n        return header + attr\n\n    def PwDecrypt(self, password):\n        \"\"\"De-Obfuscate a RADIUS password. RADIUS hides passwords in packets by\n        using an algorithm based on the MD5 hash of the packet authenticator\n        and RADIUS secret. This function reverses the obfuscation process.\n\n        Although RFC2865 does not explicitly state UTF-8 for the password field,\n        the rest of RFC2865 defines UTF-8 as the encoding expected for the decrypted password.\n\n\n        :param password: obfuscated form of password\n        :type password:  binary string\n        :return:         plaintext password\n        :rtype:          unicode string\n        \"\"\"\n        buf = password\n        pw = b\"\"\n\n        last = self.authenticator\n        while buf:\n            hash = hashlib.md5(self.secret + last).digest()\n            for i in range(16):\n                pw += bytes((hash[i] ^ buf[i],))\n            (last, buf) = (buf[:16], buf[16:])\n\n        # This is safe even with UTF-8 encoding since no valid encoding of UTF-8\n        # (other than encoding U+0000 NULL) will produce a bytestream containing 0x00 byte.\n        while pw.endswith(b\"\\x00\"):\n            pw = pw[:-1]\n\n        # If the shared secret with the client is not the same, then de-obfuscating the password\n        # field may yield illegal UTF-8 bytes. Therefore, in order not to provoke an Exception here\n        # (which would be not consistently generated since this will depend on the random data\n        # chosen by the client) we simply ignore un-parsable UTF-8 sequences.\n        return pw.decode(\"utf-8\", errors=\"ignore\")\n\n    def PwCrypt(self, password: bytes):\n        \"\"\"Obfuscate password.\n        RADIUS hides passwords in packets by using an algorithm\n        based on the MD5 hash of the packet authenticator and RADIUS\n        secret. If no authenticator has been set before calling PwCrypt\n        one is created automatically. Changing the authenticator after\n        setting a password that has been encrypted using this function\n        will not work.\n\n        :param password: plaintext password\n        :type password:  unicode string\n        :return:         obfuscated version of the password\n        :rtype:          binary string\n        \"\"\"\n        if self.authenticator is None:\n            self.authenticator = self.CreateAuthenticator()\n\n        if isinstance(password, str):\n            password = password.encode(\"utf-8\")\n\n        buf = password\n        if len(password) % 16 != 0:\n            buf += b\"\\x00\" * (16 - (len(password) % 16))\n\n        result = b\"\"\n\n        last = self.authenticator\n        while buf:\n            hash = hashlib.md5(self.secret + last).digest()\n            for i in range(16):\n                result += bytes((hash[i] ^ buf[i],))\n            last = result[-16:]\n            buf = buf[16:]\n\n        return result\n\n    def VerifyChapPasswd(self, userpwd):\n        \"\"\"Verify RADIUS ChapPasswd\n\n        :param userpwd: plaintext password\n        :type userpwd:  str\n        :return:        is verify ok\n        :rtype:         bool\n        \"\"\"\n\n        if not self.authenticator:\n            self.authenticator = self.CreateAuthenticator()\n\n        if isinstance(userpwd, str):\n            userpwd = userpwd.strip().encode(\"utf-8\")\n\n        chap_password = tools.DecodeOctets(self.get(3)[0])\n        if len(chap_password) != 17:\n            return False\n\n        chapid = chap_password[:1]\n        password = chap_password[1:]\n\n        challenge = self.authenticator\n        if \"CHAP-Challenge\" in self:\n            challenge = self[\"CHAP-Challenge\"][0]\n\n        return password == hashlib.md5(chapid + userpwd + challenge).digest()\n\n    def VerifyAuthRequest(self) -&gt; bool:\n        \"\"\"Verify request authenticator.\n\n        :return: True if verification passed else False\n        :rtype: boolean\n        \"\"\"\n        if not self.raw_packet:\n            raise ValueError(\"Raw packet not present\")\n\n        if not self.raw_packet[0] == AccessRequest:\n            return False\n\n        return True\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.AuthPacket.CreateReply","title":"<code>CreateReply(**attributes)</code>","text":"<p>Create a new packet as a reply to this one. This method makes sure the authenticator and secret are copied over to the new instance.</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def CreateReply(self, **attributes):\n    \"\"\"Create a new packet as a reply to this one. This method\n    makes sure the authenticator and secret are copied over\n    to the new instance.\n    \"\"\"\n    return AuthPacket(\n        AccessAccept,\n        self.id,\n        self.secret,\n        self.authenticator,\n        dict=self.dict,\n        auth_type=self.auth_type,\n        **attributes,\n    )\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.AuthPacket.PwCrypt","title":"<code>PwCrypt(password)</code>","text":"<p>Obfuscate password. RADIUS hides passwords in packets by using an algorithm based on the MD5 hash of the packet authenticator and RADIUS secret. If no authenticator has been set before calling PwCrypt one is created automatically. Changing the authenticator after setting a password that has been encrypted using this function will not work.</p> <p>:param password: plaintext password :type password:  unicode string :return:         obfuscated version of the password :rtype:          binary string</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def PwCrypt(self, password: bytes):\n    \"\"\"Obfuscate password.\n    RADIUS hides passwords in packets by using an algorithm\n    based on the MD5 hash of the packet authenticator and RADIUS\n    secret. If no authenticator has been set before calling PwCrypt\n    one is created automatically. Changing the authenticator after\n    setting a password that has been encrypted using this function\n    will not work.\n\n    :param password: plaintext password\n    :type password:  unicode string\n    :return:         obfuscated version of the password\n    :rtype:          binary string\n    \"\"\"\n    if self.authenticator is None:\n        self.authenticator = self.CreateAuthenticator()\n\n    if isinstance(password, str):\n        password = password.encode(\"utf-8\")\n\n    buf = password\n    if len(password) % 16 != 0:\n        buf += b\"\\x00\" * (16 - (len(password) % 16))\n\n    result = b\"\"\n\n    last = self.authenticator\n    while buf:\n        hash = hashlib.md5(self.secret + last).digest()\n        for i in range(16):\n            result += bytes((hash[i] ^ buf[i],))\n        last = result[-16:]\n        buf = buf[16:]\n\n    return result\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.AuthPacket.PwDecrypt","title":"<code>PwDecrypt(password)</code>","text":"<p>De-Obfuscate a RADIUS password. RADIUS hides passwords in packets by using an algorithm based on the MD5 hash of the packet authenticator and RADIUS secret. This function reverses the obfuscation process.</p> <p>Although RFC2865 does not explicitly state UTF-8 for the password field, the rest of RFC2865 defines UTF-8 as the encoding expected for the decrypted password.</p> <p>:param password: obfuscated form of password :type password:  binary string :return:         plaintext password :rtype:          unicode string</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def PwDecrypt(self, password):\n    \"\"\"De-Obfuscate a RADIUS password. RADIUS hides passwords in packets by\n    using an algorithm based on the MD5 hash of the packet authenticator\n    and RADIUS secret. This function reverses the obfuscation process.\n\n    Although RFC2865 does not explicitly state UTF-8 for the password field,\n    the rest of RFC2865 defines UTF-8 as the encoding expected for the decrypted password.\n\n\n    :param password: obfuscated form of password\n    :type password:  binary string\n    :return:         plaintext password\n    :rtype:          unicode string\n    \"\"\"\n    buf = password\n    pw = b\"\"\n\n    last = self.authenticator\n    while buf:\n        hash = hashlib.md5(self.secret + last).digest()\n        for i in range(16):\n            pw += bytes((hash[i] ^ buf[i],))\n        (last, buf) = (buf[:16], buf[16:])\n\n    # This is safe even with UTF-8 encoding since no valid encoding of UTF-8\n    # (other than encoding U+0000 NULL) will produce a bytestream containing 0x00 byte.\n    while pw.endswith(b\"\\x00\"):\n        pw = pw[:-1]\n\n    # If the shared secret with the client is not the same, then de-obfuscating the password\n    # field may yield illegal UTF-8 bytes. Therefore, in order not to provoke an Exception here\n    # (which would be not consistently generated since this will depend on the random data\n    # chosen by the client) we simply ignore un-parsable UTF-8 sequences.\n    return pw.decode(\"utf-8\", errors=\"ignore\")\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.AuthPacket.RequestPacket","title":"<code>RequestPacket()</code>","text":"<p>Create a ready-to-transmit authentication request packet. Return a RADIUS packet which can be directly transmitted to a RADIUS server.</p> <p>:return: raw packet :rtype:  string</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def RequestPacket(self):\n    \"\"\"Create a ready-to-transmit authentication request packet.\n    Return a RADIUS packet which can be directly transmitted\n    to a RADIUS server.\n\n    :return: raw packet\n    :rtype:  string\n    \"\"\"\n    if self.authenticator is None:\n        self.authenticator = self.CreateAuthenticator()\n\n    if self.id is None:\n        self.id = self.CreateID()\n\n    if self.message_authenticator:\n        self._refresh_message_authenticator()\n\n    attr = self._PktEncodeAttributes()\n    if self.auth_type == \"eap-md5\":\n        header = struct.pack(\n            \"!BBH16s\", self.code, self.id, (20 + 18 + len(attr)), self.authenticator\n        )\n        digest = hmac_new(\n            self.secret,\n            header\n            + attr\n            + struct.pack(\"!BB16s\", 80, struct.calcsize(\"!BB16s\"), b\"\"),\n        ).digest()\n        return (\n            header\n            + attr\n            + struct.pack(\"!BB16s\", 80, struct.calcsize(\"!BB16s\"), digest)\n        )\n\n    header = struct.pack(\n        \"!BBH16s\", self.code, self.id, (20 + len(attr)), self.authenticator\n    )\n\n    return header + attr\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.AuthPacket.VerifyAuthRequest","title":"<code>VerifyAuthRequest()</code>","text":"<p>Verify request authenticator.</p> <p>:return: True if verification passed else False :rtype: boolean</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def VerifyAuthRequest(self) -&gt; bool:\n    \"\"\"Verify request authenticator.\n\n    :return: True if verification passed else False\n    :rtype: boolean\n    \"\"\"\n    if not self.raw_packet:\n        raise ValueError(\"Raw packet not present\")\n\n    if not self.raw_packet[0] == AccessRequest:\n        return False\n\n    return True\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.AuthPacket.VerifyChapPasswd","title":"<code>VerifyChapPasswd(userpwd)</code>","text":"<p>Verify RADIUS ChapPasswd</p> <p>:param userpwd: plaintext password :type userpwd:  str :return:        is verify ok :rtype:         bool</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def VerifyChapPasswd(self, userpwd):\n    \"\"\"Verify RADIUS ChapPasswd\n\n    :param userpwd: plaintext password\n    :type userpwd:  str\n    :return:        is verify ok\n    :rtype:         bool\n    \"\"\"\n\n    if not self.authenticator:\n        self.authenticator = self.CreateAuthenticator()\n\n    if isinstance(userpwd, str):\n        userpwd = userpwd.strip().encode(\"utf-8\")\n\n    chap_password = tools.DecodeOctets(self.get(3)[0])\n    if len(chap_password) != 17:\n        return False\n\n    chapid = chap_password[:1]\n    password = chap_password[1:]\n\n    challenge = self.authenticator\n    if \"CHAP-Challenge\" in self:\n        challenge = self[\"CHAP-Challenge\"][0]\n\n    return password == hashlib.md5(chapid + userpwd + challenge).digest()\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.AuthPacket.__init__","title":"<code>__init__(code=AccessRequest, id=None, secret=b'', authenticator=None, auth_type='pap', **attributes)</code>","text":"<p>Constructor</p> <p>:param code:   packet type code :type code:    integer (8bits) :param id:     packet identification number :type id:      integer (8 bits) :param secret: secret needed to communicate with a RADIUS server :type secret:  string</p> <p>:param dict:   RADIUS dictionary :type dict:    pyrad2.dictionary.Dictionary class</p> <p>:param packet: raw packet to decode :type packet:  string</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def __init__(\n    self,\n    code=AccessRequest,\n    id=None,\n    secret=b\"\",\n    authenticator=None,\n    auth_type=\"pap\",\n    **attributes,\n):\n    \"\"\"Constructor\n\n    :param code:   packet type code\n    :type code:    integer (8bits)\n    :param id:     packet identification number\n    :type id:      integer (8 bits)\n    :param secret: secret needed to communicate with a RADIUS server\n    :type secret:  string\n\n    :param dict:   RADIUS dictionary\n    :type dict:    pyrad2.dictionary.Dictionary class\n\n    :param packet: raw packet to decode\n    :type packet:  string\n    \"\"\"\n    super().__init__(code, id, secret, authenticator, **attributes)\n    self.auth_type = auth_type\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.CoAPacket","title":"<code>CoAPacket</code>","text":"<p>               Bases: <code>Packet</code></p> <p>RADIUS CoA packets. This class is a specialization of the generic :obj:<code>Packet</code> class for CoA packets.</p> Source code in <code>pyrad2/packet.py</code> <pre><code>class CoAPacket(Packet):\n    \"\"\"RADIUS CoA packets. This class is a specialization\n    of the generic :obj:`Packet` class for CoA packets.\n    \"\"\"\n\n    def __init__(\n        self,\n        code: int = CoARequest,\n        id: Optional[int] = None,\n        secret: bytes = b\"\",\n        authenticator: Optional[bytes] = None,\n        **attributes,\n    ):\n        \"\"\"Constructor\n\n        :param dict:   RADIUS dictionary\n        :type dict:    pyrad2.dictionary.Dictionary class\n        :param secret: secret needed to communicate with a RADIUS server\n        :type secret:  string\n        :param id:     packet identification number\n        :type id:      integer (8 bits)\n        :param code:   packet type code\n        :type code:    integer (8bits)\n        :param packet: raw packet to decode\n        :type packet:  string\n        \"\"\"\n        super().__init__(code, id, secret, authenticator, **attributes)\n\n    def CreateReply(self, **attributes) -&gt; \"CoAPacket\":\n        \"\"\"Create a new packet as a reply to this one. This method\n        makes sure the authenticator and secret are copied over\n        to the new instance.\n        \"\"\"\n        return CoAPacket(\n            CoAACK,\n            self.id,\n            self.secret,\n            self.authenticator,\n            dict=self.dict,\n            **attributes,\n        )\n\n    def VerifyCoARequest(self) -&gt; bool:\n        \"\"\"Verify request authenticator.\n\n        :return: True if verification passed else False\n        :rtype: boolean\n        \"\"\"\n        return self.VerifyPacket()\n\n    def RequestPacket(self) -&gt; bytes:\n        \"\"\"Create a ready-to-transmit CoA request packet.\n        Return a RADIUS packet which can be directly transmitted\n        to a RADIUS server.\n\n        :return: raw packet\n        :rtype:  string\n        \"\"\"\n\n        attr = self._PktEncodeAttributes()\n\n        if self.id is None:\n            self.id = self.CreateID()\n\n        header = struct.pack(\"!BBH\", self.code, self.id, (20 + len(attr)))\n        self.authenticator = hashlib.md5(\n            header[0:4] + 16 * b\"\\x00\" + attr + self.secret\n        ).digest()\n\n        if self.message_authenticator:\n            self._refresh_message_authenticator()\n            attr = self._PktEncodeAttributes()\n            self.authenticator = hashlib.md5(\n                header[0:4] + 16 * b\"\\x00\" + attr + self.secret\n            ).digest()\n\n        return header + self.authenticator + attr\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.CoAPacket.CreateReply","title":"<code>CreateReply(**attributes)</code>","text":"<p>Create a new packet as a reply to this one. This method makes sure the authenticator and secret are copied over to the new instance.</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def CreateReply(self, **attributes) -&gt; \"CoAPacket\":\n    \"\"\"Create a new packet as a reply to this one. This method\n    makes sure the authenticator and secret are copied over\n    to the new instance.\n    \"\"\"\n    return CoAPacket(\n        CoAACK,\n        self.id,\n        self.secret,\n        self.authenticator,\n        dict=self.dict,\n        **attributes,\n    )\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.CoAPacket.RequestPacket","title":"<code>RequestPacket()</code>","text":"<p>Create a ready-to-transmit CoA request packet. Return a RADIUS packet which can be directly transmitted to a RADIUS server.</p> <p>:return: raw packet :rtype:  string</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def RequestPacket(self) -&gt; bytes:\n    \"\"\"Create a ready-to-transmit CoA request packet.\n    Return a RADIUS packet which can be directly transmitted\n    to a RADIUS server.\n\n    :return: raw packet\n    :rtype:  string\n    \"\"\"\n\n    attr = self._PktEncodeAttributes()\n\n    if self.id is None:\n        self.id = self.CreateID()\n\n    header = struct.pack(\"!BBH\", self.code, self.id, (20 + len(attr)))\n    self.authenticator = hashlib.md5(\n        header[0:4] + 16 * b\"\\x00\" + attr + self.secret\n    ).digest()\n\n    if self.message_authenticator:\n        self._refresh_message_authenticator()\n        attr = self._PktEncodeAttributes()\n        self.authenticator = hashlib.md5(\n            header[0:4] + 16 * b\"\\x00\" + attr + self.secret\n        ).digest()\n\n    return header + self.authenticator + attr\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.CoAPacket.VerifyCoARequest","title":"<code>VerifyCoARequest()</code>","text":"<p>Verify request authenticator.</p> <p>:return: True if verification passed else False :rtype: boolean</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def VerifyCoARequest(self) -&gt; bool:\n    \"\"\"Verify request authenticator.\n\n    :return: True if verification passed else False\n    :rtype: boolean\n    \"\"\"\n    return self.VerifyPacket()\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.CoAPacket.__init__","title":"<code>__init__(code=CoARequest, id=None, secret=b'', authenticator=None, **attributes)</code>","text":"<p>Constructor</p> <p>:param dict:   RADIUS dictionary :type dict:    pyrad2.dictionary.Dictionary class :param secret: secret needed to communicate with a RADIUS server :type secret:  string :param id:     packet identification number :type id:      integer (8 bits) :param code:   packet type code :type code:    integer (8bits) :param packet: raw packet to decode :type packet:  string</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def __init__(\n    self,\n    code: int = CoARequest,\n    id: Optional[int] = None,\n    secret: bytes = b\"\",\n    authenticator: Optional[bytes] = None,\n    **attributes,\n):\n    \"\"\"Constructor\n\n    :param dict:   RADIUS dictionary\n    :type dict:    pyrad2.dictionary.Dictionary class\n    :param secret: secret needed to communicate with a RADIUS server\n    :type secret:  string\n    :param id:     packet identification number\n    :type id:      integer (8 bits)\n    :param code:   packet type code\n    :type code:    integer (8bits)\n    :param packet: raw packet to decode\n    :type packet:  string\n    \"\"\"\n    super().__init__(code, id, secret, authenticator, **attributes)\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.Packet","title":"<code>Packet</code>","text":"<p>               Bases: <code>OrderedDict</code></p> <p>Packet acts like a standard python map to provide simple access to the RADIUS attributes. Since RADIUS allows for repeated attributes the value will always be a sequence. pyrad makes sure to preserve the ordering when encoding and decoding packets.</p> <p>There are two ways to use the map interface: if attribute names are used pyrad take care of en-/decoding data. If the attribute type number (or a vendor ID/attribute type tuple for vendor attributes) is used you work with the raw data.</p> <p>Normally you will not use this class directly, but one of the :obj:<code>AuthPacket</code> or :obj:<code>AcctPacket</code> classes.</p> Source code in <code>pyrad2/packet.py</code> <pre><code>class Packet(OrderedDict):\n    \"\"\"Packet acts like a standard python map to provide simple access\n    to the RADIUS attributes. Since RADIUS allows for repeated\n    attributes the value will always be a sequence. pyrad makes sure\n    to preserve the ordering when encoding and decoding packets.\n\n    There are two ways to use the map interface: if attribute\n    names are used pyrad take care of en-/decoding data. If\n    the attribute type number (or a vendor ID/attribute type\n    tuple for vendor attributes) is used you work with the\n    raw data.\n\n    Normally you will not use this class directly, but one of the\n    :obj:`AuthPacket` or :obj:`AcctPacket` classes.\n    \"\"\"\n\n    def __init__(\n        self,\n        code: int = 0,\n        id: Optional[int] = None,\n        secret: bytes = b\"radsec\",\n        authenticator: Optional[bytes] = None,\n        **attributes,\n    ):\n        \"\"\"Constructor\n\n        :param dict:   RADIUS dictionary\n        :type dict:    pyrad2.dictionary.Dictionary class\n        :param secret: secret needed to communicate with a RADIUS server\n        :type secret:  string\n        :param id:     packet identification number\n        :type id:      integer (8 bits)\n        :param code:   packet type code\n        :type code:    integer (8bits)\n        :param packet: raw packet to decode\n        :type packet:  string\n        \"\"\"\n        super().__init__()\n        self.code = code\n        if id is not None:\n            self.id = id\n        else:\n            self.id = CreateID()\n        if not isinstance(secret, bytes):\n            raise TypeError(\"secret must be a binary string\")\n        self.secret = secret\n        if authenticator is not None and not isinstance(authenticator, bytes):\n            raise TypeError(\"authenticator must be a binary string\")\n        self.authenticator = authenticator\n        self.message_authenticator = None\n        self.raw_packet = None\n\n        # injected by server when grabbing packet\n        self.source: list[str]\n\n        if \"dict\" in attributes:\n            self.dict = attributes[\"dict\"]\n\n        if \"packet\" in attributes:\n            self.raw_packet = attributes[\"packet\"]\n            self.DecodePacket(self.raw_packet)\n\n        if \"message_authenticator\" in attributes:\n            self.message_authenticator = attributes[\"message_authenticator\"]\n\n        for key, value in attributes.items():\n            if key in [\n                \"dict\",\n                \"fd\",\n                \"packet\",\n                \"message_authenticator\",\n            ]:\n                continue\n            key = key.replace(\"_\", \"-\")\n            self.AddAttribute(key, value)\n\n    def add_message_authenticator(self) -&gt; None:\n        self.message_authenticator = True\n        # Maintain a zero octets content for md5 and hmac calculation.\n        self[\"Message-Authenticator\"] = 16 * b\"\\00\"\n\n        if self.id is None:\n            self.id = self.CreateID()\n\n        if self.authenticator is None and self.code == AccessRequest:\n            self.authenticator = self.CreateAuthenticator()\n            self._refresh_message_authenticator()\n\n    def get_message_authenticator(self) -&gt; Optional[bool]:\n        self._refresh_message_authenticator()\n        return self.message_authenticator\n\n    def _refresh_message_authenticator(self):\n        hmac_constructor = hmac_new(self.secret)\n\n        # Maintain a zero octets content for md5 and hmac calculation.\n        self[\"Message-Authenticator\"] = 16 * b\"\\00\"\n        attr = self._PktEncodeAttributes()\n\n        header = struct.pack(\"!BBH\", self.code, self.id, (20 + len(attr)))\n\n        hmac_constructor.update(header[0:4])\n        if self.code in (\n            AccountingRequest,\n            DisconnectRequest,\n            CoARequest,\n            AccountingResponse,\n        ):\n            hmac_constructor.update(16 * b\"\\00\")\n        else:\n            # NOTE: self.authenticator on reply packet is initialized\n            #       with request authenticator by design.\n            #       For AccessAccept, AccessReject and AccessChallenge\n            #       it is needed use original Authenticator.\n            #       For AccessAccept, AccessReject and AccessChallenge\n            #       it is needed use original Authenticator.\n            if self.authenticator is None:\n                raise Exception(\"No authenticator found\")\n            hmac_constructor.update(self.authenticator)\n\n        hmac_constructor.update(attr)\n        self[\"Message-Authenticator\"] = hmac_constructor.digest()\n\n    def verify_message_authenticator(\n        self,\n        secret: Optional[bytes] = None,\n        original_authenticator=None,\n        original_code=None,\n    ) -&gt; bool:\n        \"\"\"Verify packet Message-Authenticator.\n\n        :return: False if verification failed else True\n        :rtype: boolean\n        \"\"\"\n        if self.message_authenticator is None:\n            raise Exception(\"No Message-Authenticator AVP present\")\n\n        prev_ma = self[\"Message-Authenticator\"]\n        # Set zero bytes for Message-Authenticator for md5 calculation\n        if secret is None and self.secret is None:\n            raise Exception(\"Missing secret for HMAC/MD5 verification\")\n\n        if secret:\n            key = secret\n        else:\n            key = self.secret\n\n        # If there's a raw packet, use that to calculate the expected\n        # Message-Authenticator. While the Packet class keeps multiple\n        # instances of an attribute grouped together in the attribute list,\n        # other applications may not. Using _PktEncodeAttributes to get\n        # the attributes could therefore end up changing the attribute order\n        # because of the grouping Packet does, which would cause\n        # Message-Authenticator verification to fail. Using the raw packet\n        # instead, if present, ensures the verification is done using the\n        # attributes exactly as sent.\n        if self.raw_packet:\n            attr = self.raw_packet[20:]\n            attr = attr.replace(prev_ma[0], 16 * b\"\\00\")\n        else:\n            self[\"Message-Authenticator\"] = 16 * b\"\\00\"\n            attr = self._PktEncodeAttributes()\n\n        header = struct.pack(\"!BBH\", self.code, self.id, (20 + len(attr)))\n\n        hmac_constructor = hmac_new(key)\n        hmac_constructor.update(header)\n        if self.code in (\n            AccountingRequest,\n            DisconnectRequest,\n            CoARequest,\n            AccountingResponse,\n        ):\n            if original_code is None or original_code != StatusServer:\n                # TODO: Handle Status-Server response correctly.\n                hmac_constructor.update(16 * b\"\\00\")\n        elif self.code in (AccessAccept, AccessChallenge, AccessReject):\n            if original_authenticator is None:\n                if self.authenticator:\n                    # NOTE: self.authenticator on reply packet is initialized\n                    #       with request authenticator by design.\n                    original_authenticator = self.authenticator\n                else:\n                    raise Exception(\"Missing original authenticator\")\n\n            hmac_constructor.update(original_authenticator)\n        else:\n            # On Access-Request and Status-Server use dynamic authenticator\n            hmac_constructor.update(self.authenticator)\n\n        hmac_constructor.update(attr)\n        self[\"Message-Authenticator\"] = prev_ma[0]\n        return prev_ma[0] == hmac_constructor.digest()\n\n    def CreateReply(self, **attributes) -&gt; \"Packet\":\n        \"\"\"Create a new packet as a reply to this one. This method\n        makes sure the authenticator and secret are copied over\n        to the new instance.\n        \"\"\"\n        return Packet(\n            id=self.id,\n            secret=self.secret,\n            authenticator=self.authenticator,\n            dict=self.dict,\n            **attributes,\n        )\n\n    def _DecodeValue(self, attr: Attribute, value: bytes) -&gt; bytes | str:\n        if attr.encrypt == 2:\n            # salt decrypt attribute\n            value = self.SaltDecrypt(value)\n\n        if attr.values.HasBackward(value):\n            return attr.values.GetBackward(value)\n        else:\n            return tools.DecodeAttr(attr.type, value)\n\n    def _EncodeValue(self, attr: Attribute, value: bytes | str) -&gt; bytes:\n        if attr.values.HasForward(value):\n            result = attr.values.GetForward(value)\n        else:\n            result = tools.EncodeAttr(attr.type, value)\n\n        if attr.encrypt == 2:\n            # salt encrypt attribute\n            result = self.SaltCrypt(result)\n\n        return result\n\n    def _EncodeKeyValues(self, key: Hashable, values):\n        if not isinstance(key, str):\n            return (key, values)\n\n        if not isinstance(values, (list, tuple)):\n            values = [values]\n\n        key, _, tag = key.partition(\":\")\n        attr = self.dict.attributes[key]\n        key = self._EncodeKey(key)\n        if tag:\n            tag_bytes = struct.pack(\"B\", int(tag))\n            if attr.type == \"integer\":\n                return (\n                    key,\n                    [tag_bytes + self._EncodeValue(attr, v)[1:] for v in values],\n                )\n            else:\n                return (key, [tag_bytes + self._EncodeValue(attr, v) for v in values])\n        else:\n            return (key, [self._EncodeValue(attr, v) for v in values])\n\n    def _EncodeKey(self, key: str):\n        if not isinstance(key, str):\n            return key\n\n        attr = self.dict.attributes[key]\n        if (\n            attr.vendor and not attr.is_sub_attribute\n        ):  # sub attribute keys don't need vendor\n            return (self.dict.vendors.GetForward(attr.vendor), attr.code)\n        else:\n            return attr.code\n\n    def _DecodeKey(self, key: str) -&gt; str:\n        \"\"\"Turn a key into a string if possible\"\"\"\n\n        if self.dict.attrindex.HasBackward(key):\n            return self.dict.attrindex.GetBackward(key)\n        return key\n\n    def AddAttribute(self, key: str, value: RadiusAttributeValue):\n        \"\"\"Add an attribute to the packet.\n\n        :param key:   attribute name or identification\n        :type key:    string, attribute code or (vendor code, attribute code)\n                      tuple\n        :param value: value\n        :type value:  depends on type of attribute\n        \"\"\"\n        attr = self.dict.attributes[key.partition(\":\")[0]]\n\n        (key, value) = self._EncodeKeyValues(key, value)\n\n        if attr.is_sub_attribute:\n            tlv = self.setdefault(self._EncodeKey(attr.parent.name), {})\n            encoded = tlv.setdefault(key, [])\n        else:\n            encoded = self.setdefault(key, [])\n\n        encoded.extend(value)\n\n    def get(self, key: str, failobj: Any = None):\n        try:\n            res = self.__getitem__(key)\n        except KeyError:\n            res = failobj\n        return res\n\n    def __getitem__(self, key):\n        if not isinstance(key, str):\n            return super().__getitem__(key)\n\n        values = super().__getitem__(self._EncodeKey(key))\n        attr = self.dict.attributes[key]\n        if attr.type == \"tlv\":  # return map from sub attribute code to its values\n            res = {}\n            for sub_attr_key, sub_attr_val in values.items():\n                sub_attr_name = attr.sub_attributes[sub_attr_key]\n                sub_attr = self.dict.attributes[sub_attr_name]\n                for v in sub_attr_val:\n                    res.setdefault(sub_attr_name, []).append(\n                        self._DecodeValue(sub_attr, v)\n                    )\n            return res\n        else:\n            res = []\n            for v in values:\n                res.append(self._DecodeValue(attr, v))\n            return res\n\n    def __contains__(self, key) -&gt; bool:\n        try:\n            return super().__contains__(self._EncodeKey(key))\n        except KeyError:\n            return False\n\n    has_key = __contains__\n\n    def __delitem__(self, key) -&gt; None:\n        super().__delitem__(self._EncodeKey(key))\n\n    def __setitem__(self, key, item):\n        if isinstance(key, str):\n            (key, item) = self._EncodeKeyValues(key, item)\n            super().__setitem__(key, item)\n        else:\n            super().__setitem__(key, item)\n\n    def keys(self):\n        return [self._DecodeKey(key) for key in OrderedDict.keys(self)]\n\n    @staticmethod\n    def CreateAuthenticator():\n        \"\"\"Create a packet authenticator. All RADIUS packets contain a sixteen\n        byte authenticator which is used to authenticate replies from the\n        RADIUS server and in the password hiding algorithm. This function\n        returns a suitable random string that can be used as an authenticator.\n\n        :return: valid packet authenticator\n        :rtype: binary string\n        \"\"\"\n        return bytes(random_generator.randrange(0, 256) for _ in range(16))\n\n    def CreateID(self):\n        \"\"\"Create a packet ID.  All RADIUS requests have a ID which is used to\n        identify a request. This is used to detect retries and replay attacks.\n        This function returns a suitable random number that can be used as ID.\n\n        :return: ID number\n        :rtype:  integer\n\n        \"\"\"\n        return random_generator.randrange(0, 256)\n\n    def ReplyPacket(self):\n        \"\"\"Create a ready-to-transmit authentication reply packet.\n        Returns a RADIUS packet which can be directly transmitted\n        to a RADIUS server. This differs with Packet() in how\n        the authenticator is calculated.\n\n        :return: raw packet\n        :rtype:  string\n        \"\"\"\n        assert self.authenticator\n\n        assert self.secret is not None\n\n        if self.message_authenticator:\n            self._refresh_message_authenticator()\n\n        attr = self._PktEncodeAttributes()\n        header = struct.pack(\"!BBH\", self.code, self.id, (20 + len(attr)))\n\n        authenticator = hashlib.md5(\n            header[0:4] + self.authenticator + attr + self.secret\n        ).digest()\n\n        return header + authenticator + attr\n\n    def VerifyReply(self, reply, rawreply=None):\n        if reply.id != self.id:\n            return False\n\n        if rawreply is None:\n            rawreply = reply.ReplyPacket()\n\n        reply._PktEncodeAttributes()\n        # The Authenticator field in an Accounting-Response packet is called\n        # the Response Authenticator, and contains a one-way MD5 hash\n        # calculated over a stream of octets consisting of the Accounting\n        # Response Code, Identifier, Length, the Request Authenticator field\n        # from the Accounting-Request packet being replied to, and the\n        # response attributes if any, followed by the shared secret.  The\n        # resulting 16 octet MD5 hash value is stored in the Authenticator\n        # field of the Accounting-Response packet.\n        hash = hashlib.md5(\n            rawreply[0:4] + self.authenticator + rawreply[20:] + self.secret  # type: ignore\n        ).digest()\n\n        if hash != rawreply[4:20]:\n            return False\n        return True\n\n    def _PktEncodeAttribute(self, key, value):\n        if isinstance(key, tuple):\n            value = struct.pack(\"!L\", key[0]) + self._PktEncodeAttribute(key[1], value)\n            key = 26\n\n        return struct.pack(\"!BB\", key, (len(value) + 2)) + value\n\n    def _PktEncodeTlv(self, tlv_key, tlv_value):\n        tlv_attr = self.dict.attributes[self._DecodeKey(tlv_key)]\n        curr_avp = b\"\"\n        avps = []\n        max_sub_attribute_len = max(map(lambda item: len(item[1]), tlv_value.items()))\n        for i in range(max_sub_attribute_len):\n            sub_attr_encoding = b\"\"\n            for code, datalst in tlv_value.items():\n                if i &lt; len(datalst):\n                    sub_attr_encoding += self._PktEncodeAttribute(code, datalst[i])\n            # split above 255. assuming len of one instance of all sub tlvs is lower than 255\n            if (len(sub_attr_encoding) + len(curr_avp)) &lt; 245:\n                curr_avp += sub_attr_encoding\n            else:\n                avps.append(curr_avp)\n                curr_avp = sub_attr_encoding\n        avps.append(curr_avp)\n        tlv_avps = []\n        for avp in avps:\n            value = struct.pack(\"!BB\", tlv_attr.code, (len(avp) + 2)) + avp\n            tlv_avps.append(value)\n        if tlv_attr.vendor:\n            vendor_avps = b\"\"\n            for avp in tlv_avps:\n                vendor_avps += (\n                    struct.pack(\n                        \"!BBL\",\n                        26,\n                        (len(avp) + 6),\n                        self.dict.vendors.GetForward(tlv_attr.vendor),\n                    )\n                    + avp\n                )\n            return vendor_avps\n        else:\n            return b\"\".join(tlv_avps)\n\n    def _PktEncodeAttributes(self):\n        result = b\"\"\n        for code, datalst in self.items():\n            attribute = self.dict.attributes.get(self._DecodeKey(code))\n            if attribute and attribute.type == \"tlv\":\n                result += self._PktEncodeTlv(code, datalst)\n            else:\n                for data in datalst:\n                    result += self._PktEncodeAttribute(code, data)\n        return result\n\n    def _PktDecodeVendorAttribute(self, data):\n        # Check if this packet is long enough to be in the\n        # RFC2865 recommended form\n        if len(data) &lt; 6:\n            return [(26, data)]\n\n        (vendor, atype, length) = struct.unpack(\"!LBB\", data[:6])[0:3]\n        attribute = self.dict.attributes.get(self._DecodeKey((vendor, atype)))\n        try:\n            if attribute and attribute.type == \"tlv\":\n                self._PktDecodeTlvAttribute((vendor, atype), data[6 : length + 4])\n                tlvs = []  # tlv is added to the packet inside _PktDecodeTlvAttribute\n            else:\n                tlvs = [((vendor, atype), data[6 : length + 4])]\n        except Exception:\n            return [(26, data)]\n\n        sumlength = 4 + length\n        while len(data) &gt; sumlength:\n            try:\n                atype, length = struct.unpack(\"!BB\", data[sumlength : sumlength + 2])[\n                    0:2\n                ]\n            except Exception:\n                return [(26, data)]\n            tlvs.append(((vendor, atype), data[sumlength + 2 : sumlength + length]))\n            sumlength += length\n        return tlvs\n\n    def _PktDecodeTlvAttribute(self, code, data):\n        sub_attributes = self.setdefault(code, {})\n        loc = 0\n\n        while loc &lt; len(data):\n            atype, length = struct.unpack(\"!BB\", data[loc : loc + 2])[0:2]\n            sub_attributes.setdefault(atype, []).append(data[loc + 2 : loc + length])\n            loc += length\n\n    def DecodePacket(self, packet):\n        \"\"\"Initialize the object from raw packet data.  Decode a packet as\n        received from the network and decode it.\n\n        :param packet: raw packet\n        :type packet:  string\"\"\"\n\n        try:\n            (self.code, self.id, length, self.authenticator) = struct.unpack(\n                \"!BBH16s\", packet[0:20]\n            )\n\n        except struct.error:\n            raise PacketError(\"Packet header is corrupt\")\n        if len(packet) != length:\n            raise PacketError(\"Packet has invalid length\")\n        if length &gt; 8192:\n            raise PacketError(\"Packet length is too long (%d)\" % length)\n\n        self.clear()\n\n        packet = packet[20:]\n        while packet:\n            try:\n                (key, attrlen) = struct.unpack(\"!BB\", packet[0:2])\n            except struct.error:\n                raise PacketError(\"Attribute header is corrupt\")\n\n            if attrlen &lt; 2:\n                raise PacketError(\"Attribute length is too small (%d)\" % attrlen)\n\n            value = packet[2:attrlen]\n            attribute = self.dict.attributes.get(self._DecodeKey(key))\n            if key == 26:\n                for key, value in self._PktDecodeVendorAttribute(value):\n                    self.setdefault(key, []).append(value)\n            elif key == 80:\n                # POST: Message Authenticator AVP is present.\n                self.message_authenticator = True\n                self.setdefault(key, []).append(value)\n            elif attribute and attribute.type == \"tlv\":\n                self._PktDecodeTlvAttribute(key, value)\n            else:\n                self.setdefault(key, []).append(value)\n\n            packet = packet[attrlen:]\n\n    def _salt_en_decrypt(self, data, salt):\n        result = b\"\"\n        last = self.authenticator + salt\n        while data:\n            hash = hashlib.md5(self.secret + last).digest()\n            for i in range(16):\n                result += bytes((hash[i] ^ data[i],))\n\n            last = result[-16:]\n            data = data[16:]\n        return result\n\n    def SaltCrypt(self, value):\n        \"\"\"SaltEncrypt\n\n        :param value:    plaintext value\n        :type:           unicode string\n        :return:         obfuscated version of the value\n        :rtype:          binary string\n        \"\"\"\n\n        if isinstance(value, str):\n            value = value.encode(\"utf-8\")\n\n        if self.authenticator is None:\n            # self.authenticator = self.CreateAuthenticator()\n            self.authenticator = 16 * b\"\\x00\"\n\n        # create salt\n        random_value = 32768 + random_generator.randrange(0, 32767)\n        salt_raw = struct.pack(\"!H\", random_value)\n\n        # length prefixing\n        length = struct.pack(\"B\", len(value))\n        value = length + value\n\n        # zero padding\n        if len(value) % 16 != 0:\n            value += b\"\\x00\" * (16 - (len(value) % 16))\n\n        return salt_raw + self._salt_en_decrypt(value, salt_raw)\n\n    def SaltDecrypt(self, value):\n        \"\"\"SaltDecrypt\n\n        :param value:   encrypted value including salt\n        :type:          binary string\n        :return:        decrypted plaintext string\n        :rtype:         unicode string\n        \"\"\"\n        # extract salt\n        salt = value[:2]\n\n        # decrypt\n        value = self._salt_en_decrypt(value[2:], salt)\n\n        # remove padding\n        length = value[0]\n        value = value[1 : length + 1]\n\n        return value\n\n    def VerifyPacket(self):\n        \"\"\"Verify request.\n\n        :return: True if verification passed else False\n        :rtype: boolean\n        \"\"\"\n        assert self.raw_packet\n        hash = hashlib.md5(\n            self.raw_packet[0:4] + 16 * b\"\\x00\" + self.raw_packet[20:] + self.secret\n        ).digest()\n        return hash == self.authenticator\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.Packet.AddAttribute","title":"<code>AddAttribute(key, value)</code>","text":"<p>Add an attribute to the packet.</p> <p>:param key:   attribute name or identification :type key:    string, attribute code or (vendor code, attribute code)               tuple :param value: value :type value:  depends on type of attribute</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def AddAttribute(self, key: str, value: RadiusAttributeValue):\n    \"\"\"Add an attribute to the packet.\n\n    :param key:   attribute name or identification\n    :type key:    string, attribute code or (vendor code, attribute code)\n                  tuple\n    :param value: value\n    :type value:  depends on type of attribute\n    \"\"\"\n    attr = self.dict.attributes[key.partition(\":\")[0]]\n\n    (key, value) = self._EncodeKeyValues(key, value)\n\n    if attr.is_sub_attribute:\n        tlv = self.setdefault(self._EncodeKey(attr.parent.name), {})\n        encoded = tlv.setdefault(key, [])\n    else:\n        encoded = self.setdefault(key, [])\n\n    encoded.extend(value)\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.Packet.CreateAuthenticator","title":"<code>CreateAuthenticator()</code>  <code>staticmethod</code>","text":"<p>Create a packet authenticator. All RADIUS packets contain a sixteen byte authenticator which is used to authenticate replies from the RADIUS server and in the password hiding algorithm. This function returns a suitable random string that can be used as an authenticator.</p> <p>:return: valid packet authenticator :rtype: binary string</p> Source code in <code>pyrad2/packet.py</code> <pre><code>@staticmethod\ndef CreateAuthenticator():\n    \"\"\"Create a packet authenticator. All RADIUS packets contain a sixteen\n    byte authenticator which is used to authenticate replies from the\n    RADIUS server and in the password hiding algorithm. This function\n    returns a suitable random string that can be used as an authenticator.\n\n    :return: valid packet authenticator\n    :rtype: binary string\n    \"\"\"\n    return bytes(random_generator.randrange(0, 256) for _ in range(16))\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.Packet.CreateID","title":"<code>CreateID()</code>","text":"<p>Create a packet ID.  All RADIUS requests have a ID which is used to identify a request. This is used to detect retries and replay attacks. This function returns a suitable random number that can be used as ID.</p> <p>:return: ID number :rtype:  integer</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def CreateID(self):\n    \"\"\"Create a packet ID.  All RADIUS requests have a ID which is used to\n    identify a request. This is used to detect retries and replay attacks.\n    This function returns a suitable random number that can be used as ID.\n\n    :return: ID number\n    :rtype:  integer\n\n    \"\"\"\n    return random_generator.randrange(0, 256)\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.Packet.CreateReply","title":"<code>CreateReply(**attributes)</code>","text":"<p>Create a new packet as a reply to this one. This method makes sure the authenticator and secret are copied over to the new instance.</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def CreateReply(self, **attributes) -&gt; \"Packet\":\n    \"\"\"Create a new packet as a reply to this one. This method\n    makes sure the authenticator and secret are copied over\n    to the new instance.\n    \"\"\"\n    return Packet(\n        id=self.id,\n        secret=self.secret,\n        authenticator=self.authenticator,\n        dict=self.dict,\n        **attributes,\n    )\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.Packet.DecodePacket","title":"<code>DecodePacket(packet)</code>","text":"<p>Initialize the object from raw packet data.  Decode a packet as received from the network and decode it.</p> <p>:param packet: raw packet :type packet:  string</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def DecodePacket(self, packet):\n    \"\"\"Initialize the object from raw packet data.  Decode a packet as\n    received from the network and decode it.\n\n    :param packet: raw packet\n    :type packet:  string\"\"\"\n\n    try:\n        (self.code, self.id, length, self.authenticator) = struct.unpack(\n            \"!BBH16s\", packet[0:20]\n        )\n\n    except struct.error:\n        raise PacketError(\"Packet header is corrupt\")\n    if len(packet) != length:\n        raise PacketError(\"Packet has invalid length\")\n    if length &gt; 8192:\n        raise PacketError(\"Packet length is too long (%d)\" % length)\n\n    self.clear()\n\n    packet = packet[20:]\n    while packet:\n        try:\n            (key, attrlen) = struct.unpack(\"!BB\", packet[0:2])\n        except struct.error:\n            raise PacketError(\"Attribute header is corrupt\")\n\n        if attrlen &lt; 2:\n            raise PacketError(\"Attribute length is too small (%d)\" % attrlen)\n\n        value = packet[2:attrlen]\n        attribute = self.dict.attributes.get(self._DecodeKey(key))\n        if key == 26:\n            for key, value in self._PktDecodeVendorAttribute(value):\n                self.setdefault(key, []).append(value)\n        elif key == 80:\n            # POST: Message Authenticator AVP is present.\n            self.message_authenticator = True\n            self.setdefault(key, []).append(value)\n        elif attribute and attribute.type == \"tlv\":\n            self._PktDecodeTlvAttribute(key, value)\n        else:\n            self.setdefault(key, []).append(value)\n\n        packet = packet[attrlen:]\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.Packet.ReplyPacket","title":"<code>ReplyPacket()</code>","text":"<p>Create a ready-to-transmit authentication reply packet. Returns a RADIUS packet which can be directly transmitted to a RADIUS server. This differs with Packet() in how the authenticator is calculated.</p> <p>:return: raw packet :rtype:  string</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def ReplyPacket(self):\n    \"\"\"Create a ready-to-transmit authentication reply packet.\n    Returns a RADIUS packet which can be directly transmitted\n    to a RADIUS server. This differs with Packet() in how\n    the authenticator is calculated.\n\n    :return: raw packet\n    :rtype:  string\n    \"\"\"\n    assert self.authenticator\n\n    assert self.secret is not None\n\n    if self.message_authenticator:\n        self._refresh_message_authenticator()\n\n    attr = self._PktEncodeAttributes()\n    header = struct.pack(\"!BBH\", self.code, self.id, (20 + len(attr)))\n\n    authenticator = hashlib.md5(\n        header[0:4] + self.authenticator + attr + self.secret\n    ).digest()\n\n    return header + authenticator + attr\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.Packet.SaltCrypt","title":"<code>SaltCrypt(value)</code>","text":"<p>SaltEncrypt</p> <p>:param value:    plaintext value :type:           unicode string :return:         obfuscated version of the value :rtype:          binary string</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def SaltCrypt(self, value):\n    \"\"\"SaltEncrypt\n\n    :param value:    plaintext value\n    :type:           unicode string\n    :return:         obfuscated version of the value\n    :rtype:          binary string\n    \"\"\"\n\n    if isinstance(value, str):\n        value = value.encode(\"utf-8\")\n\n    if self.authenticator is None:\n        # self.authenticator = self.CreateAuthenticator()\n        self.authenticator = 16 * b\"\\x00\"\n\n    # create salt\n    random_value = 32768 + random_generator.randrange(0, 32767)\n    salt_raw = struct.pack(\"!H\", random_value)\n\n    # length prefixing\n    length = struct.pack(\"B\", len(value))\n    value = length + value\n\n    # zero padding\n    if len(value) % 16 != 0:\n        value += b\"\\x00\" * (16 - (len(value) % 16))\n\n    return salt_raw + self._salt_en_decrypt(value, salt_raw)\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.Packet.SaltDecrypt","title":"<code>SaltDecrypt(value)</code>","text":"<p>SaltDecrypt</p> <p>:param value:   encrypted value including salt :type:          binary string :return:        decrypted plaintext string :rtype:         unicode string</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def SaltDecrypt(self, value):\n    \"\"\"SaltDecrypt\n\n    :param value:   encrypted value including salt\n    :type:          binary string\n    :return:        decrypted plaintext string\n    :rtype:         unicode string\n    \"\"\"\n    # extract salt\n    salt = value[:2]\n\n    # decrypt\n    value = self._salt_en_decrypt(value[2:], salt)\n\n    # remove padding\n    length = value[0]\n    value = value[1 : length + 1]\n\n    return value\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.Packet.VerifyPacket","title":"<code>VerifyPacket()</code>","text":"<p>Verify request.</p> <p>:return: True if verification passed else False :rtype: boolean</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def VerifyPacket(self):\n    \"\"\"Verify request.\n\n    :return: True if verification passed else False\n    :rtype: boolean\n    \"\"\"\n    assert self.raw_packet\n    hash = hashlib.md5(\n        self.raw_packet[0:4] + 16 * b\"\\x00\" + self.raw_packet[20:] + self.secret\n    ).digest()\n    return hash == self.authenticator\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.Packet.__init__","title":"<code>__init__(code=0, id=None, secret=b'radsec', authenticator=None, **attributes)</code>","text":"<p>Constructor</p> <p>:param dict:   RADIUS dictionary :type dict:    pyrad2.dictionary.Dictionary class :param secret: secret needed to communicate with a RADIUS server :type secret:  string :param id:     packet identification number :type id:      integer (8 bits) :param code:   packet type code :type code:    integer (8bits) :param packet: raw packet to decode :type packet:  string</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def __init__(\n    self,\n    code: int = 0,\n    id: Optional[int] = None,\n    secret: bytes = b\"radsec\",\n    authenticator: Optional[bytes] = None,\n    **attributes,\n):\n    \"\"\"Constructor\n\n    :param dict:   RADIUS dictionary\n    :type dict:    pyrad2.dictionary.Dictionary class\n    :param secret: secret needed to communicate with a RADIUS server\n    :type secret:  string\n    :param id:     packet identification number\n    :type id:      integer (8 bits)\n    :param code:   packet type code\n    :type code:    integer (8bits)\n    :param packet: raw packet to decode\n    :type packet:  string\n    \"\"\"\n    super().__init__()\n    self.code = code\n    if id is not None:\n        self.id = id\n    else:\n        self.id = CreateID()\n    if not isinstance(secret, bytes):\n        raise TypeError(\"secret must be a binary string\")\n    self.secret = secret\n    if authenticator is not None and not isinstance(authenticator, bytes):\n        raise TypeError(\"authenticator must be a binary string\")\n    self.authenticator = authenticator\n    self.message_authenticator = None\n    self.raw_packet = None\n\n    # injected by server when grabbing packet\n    self.source: list[str]\n\n    if \"dict\" in attributes:\n        self.dict = attributes[\"dict\"]\n\n    if \"packet\" in attributes:\n        self.raw_packet = attributes[\"packet\"]\n        self.DecodePacket(self.raw_packet)\n\n    if \"message_authenticator\" in attributes:\n        self.message_authenticator = attributes[\"message_authenticator\"]\n\n    for key, value in attributes.items():\n        if key in [\n            \"dict\",\n            \"fd\",\n            \"packet\",\n            \"message_authenticator\",\n        ]:\n            continue\n        key = key.replace(\"_\", \"-\")\n        self.AddAttribute(key, value)\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.Packet.verify_message_authenticator","title":"<code>verify_message_authenticator(secret=None, original_authenticator=None, original_code=None)</code>","text":"<p>Verify packet Message-Authenticator.</p> <p>:return: False if verification failed else True :rtype: boolean</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def verify_message_authenticator(\n    self,\n    secret: Optional[bytes] = None,\n    original_authenticator=None,\n    original_code=None,\n) -&gt; bool:\n    \"\"\"Verify packet Message-Authenticator.\n\n    :return: False if verification failed else True\n    :rtype: boolean\n    \"\"\"\n    if self.message_authenticator is None:\n        raise Exception(\"No Message-Authenticator AVP present\")\n\n    prev_ma = self[\"Message-Authenticator\"]\n    # Set zero bytes for Message-Authenticator for md5 calculation\n    if secret is None and self.secret is None:\n        raise Exception(\"Missing secret for HMAC/MD5 verification\")\n\n    if secret:\n        key = secret\n    else:\n        key = self.secret\n\n    # If there's a raw packet, use that to calculate the expected\n    # Message-Authenticator. While the Packet class keeps multiple\n    # instances of an attribute grouped together in the attribute list,\n    # other applications may not. Using _PktEncodeAttributes to get\n    # the attributes could therefore end up changing the attribute order\n    # because of the grouping Packet does, which would cause\n    # Message-Authenticator verification to fail. Using the raw packet\n    # instead, if present, ensures the verification is done using the\n    # attributes exactly as sent.\n    if self.raw_packet:\n        attr = self.raw_packet[20:]\n        attr = attr.replace(prev_ma[0], 16 * b\"\\00\")\n    else:\n        self[\"Message-Authenticator\"] = 16 * b\"\\00\"\n        attr = self._PktEncodeAttributes()\n\n    header = struct.pack(\"!BBH\", self.code, self.id, (20 + len(attr)))\n\n    hmac_constructor = hmac_new(key)\n    hmac_constructor.update(header)\n    if self.code in (\n        AccountingRequest,\n        DisconnectRequest,\n        CoARequest,\n        AccountingResponse,\n    ):\n        if original_code is None or original_code != StatusServer:\n            # TODO: Handle Status-Server response correctly.\n            hmac_constructor.update(16 * b\"\\00\")\n    elif self.code in (AccessAccept, AccessChallenge, AccessReject):\n        if original_authenticator is None:\n            if self.authenticator:\n                # NOTE: self.authenticator on reply packet is initialized\n                #       with request authenticator by design.\n                original_authenticator = self.authenticator\n            else:\n                raise Exception(\"Missing original authenticator\")\n\n        hmac_constructor.update(original_authenticator)\n    else:\n        # On Access-Request and Status-Server use dynamic authenticator\n        hmac_constructor.update(self.authenticator)\n\n    hmac_constructor.update(attr)\n    self[\"Message-Authenticator\"] = prev_ma[0]\n    return prev_ma[0] == hmac_constructor.digest()\n</code></pre>"},{"location":"api/packet/#pyrad2.packet.CreateID","title":"<code>CreateID()</code>","text":"<p>Generate a packet ID.</p> <p>:return: packet ID :rtype:  8 bit integer</p> Source code in <code>pyrad2/packet.py</code> <pre><code>def CreateID() -&gt; int:\n    \"\"\"Generate a packet ID.\n\n    :return: packet ID\n    :rtype:  8 bit integer\n    \"\"\"\n    global CurrentID\n\n    CurrentID = (CurrentID + 1) % 256\n    return CurrentID\n</code></pre>"},{"location":"api/proxy/","title":"Proxy","text":""},{"location":"api/proxy/#pyrad2.proxy.Proxy","title":"<code>Proxy</code>","text":"<p>               Bases: <code>Server</code></p> <p>Base class for RADIUS proxies. This class extends tha RADIUS server class with the capability to handle communication with other RADIUS servers as well.</p> <p>:ivar _proxyfd: network socket used to communicate with other servers :type _proxyfd: socket class instance</p> Source code in <code>pyrad2/proxy.py</code> <pre><code>class Proxy(Server):\n    \"\"\"Base class for RADIUS proxies.\n    This class extends tha RADIUS server class with the capability to\n    handle communication with other RADIUS servers as well.\n\n    :ivar _proxyfd: network socket used to communicate with other servers\n    :type _proxyfd: socket class instance\n    \"\"\"\n\n    def _PrepareSockets(self):\n        super()._PrepareSockets()\n        self._proxyfd = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self._fdmap[self._proxyfd.fileno()] = self._proxyfd\n        self._poll.register(\n            self._proxyfd.fileno(), (select.POLLIN | select.POLLPRI | select.POLLERR)\n        )\n\n    def _HandleProxyPacket(self, pkt: packet.Packet) -&gt; None:\n        \"\"\"Process a packet received on the reply socket.\n        If this packet should be dropped instead of processed a\n        :obj:`ServerPacketError` exception should be raised. The main loop\n        will drop the packet and log the reason.\n\n        :param pkt: packet to process\n        :type  pkt: Packet class instance\n        \"\"\"\n        if pkt.source[0] not in self.hosts:\n            raise ServerPacketError(\"Received packet from unknown host\")\n        pkt.secret = self.hosts[pkt.source[0]].secret\n\n        if pkt.code not in [\n            packet.AccessAccept,\n            packet.AccessReject,\n            packet.AccountingResponse,\n        ]:\n            raise ServerPacketError(\"Received non-response on proxy socket\")\n\n    def _ProcessInput(self, fd: socket.socket) -&gt; None:\n        \"\"\"Process available data.\n        If this packet should be dropped instead of processed a\n        `ServerPacketError` exception should be raised. The main loop\n        will drop the packet and log the reason.\n\n        This function calls either :obj:`HandleAuthPacket`,\n        :obj:`HandleAcctPacket` or :obj:`_HandleProxyPacket` depending on\n        which socket is being processed.\n\n        :param  fd: socket to read packet from\n        :type   fd: socket class instance\n        :param pkt: packet to process\n        :type  pkt: Packet class instance\n        \"\"\"\n        if fd.fileno() == self._proxyfd.fileno():\n            pkt = self._GrabPacket(lambda data, s=self: s.CreatePacket(packet=data), fd)\n            self._HandleProxyPacket(pkt)\n        else:\n            Server._ProcessInput(self, fd)\n</code></pre>"},{"location":"api/server/","title":"Server","text":""},{"location":"api/server/#pyrad2.server.RemoteHost","title":"<code>RemoteHost</code>  <code>dataclass</code>","text":"<p>Remote RADIUS capable host we can talk to.</p> <p>:param   address: IP address :type    address: string :param    secret: RADIUS secret :type     secret: string :param      name: short name (used for logging only) :type       name: string :param  authport: port used for authentication packets :type   authport: integer :param  acctport: port used for accounting packets :type   acctport: integer :param   coaport: port used for CoA packets :type    coaport: integer</p> Source code in <code>pyrad2/server.py</code> <pre><code>@dataclass\nclass RemoteHost:\n    \"\"\"Remote RADIUS capable host we can talk to.\n\n    :param   address: IP address\n    :type    address: string\n    :param    secret: RADIUS secret\n    :type     secret: string\n    :param      name: short name (used for logging only)\n    :type       name: string\n    :param  authport: port used for authentication packets\n    :type   authport: integer\n    :param  acctport: port used for accounting packets\n    :type   acctport: integer\n    :param   coaport: port used for CoA packets\n    :type    coaport: integer\n    \"\"\"\n\n    address: str\n    secret: bytes\n    name: str\n    authport: int = 1812\n    acctport: int = 1813\n    coaport: int = 3799\n</code></pre>"},{"location":"api/server/#pyrad2.server.Server","title":"<code>Server</code>","text":"<p>               Bases: <code>Host</code></p> <p>Basic RADIUS server. This class implements the basics of a RADIUS server. It takes care of the details of receiving and decoding requests; processing of the requests should be done by overloading the appropriate methods in derived classes.</p> <p>:ivar  hosts: hosts who are allowed to talk to us :type  hosts: dictionary of Host class instances :ivar  _poll: poll object for network sockets :type  _poll: select.poll class instance :ivar _fdmap: map of filedescriptors to network sockets :type _fdmap: dictionary :cvar MaxPacketSize: maximum size of a RADIUS packet :type MaxPacketSize: integer</p> Source code in <code>pyrad2/server.py</code> <pre><code>class Server(host.Host):\n    \"\"\"Basic RADIUS server.\n    This class implements the basics of a RADIUS server. It takes care\n    of the details of receiving and decoding requests; processing of\n    the requests should be done by overloading the appropriate methods\n    in derived classes.\n\n    :ivar  hosts: hosts who are allowed to talk to us\n    :type  hosts: dictionary of Host class instances\n    :ivar  _poll: poll object for network sockets\n    :type  _poll: select.poll class instance\n    :ivar _fdmap: map of filedescriptors to network sockets\n    :type _fdmap: dictionary\n    :cvar MaxPacketSize: maximum size of a RADIUS packet\n    :type MaxPacketSize: integer\n    \"\"\"\n\n    MaxPacketSize = 8192\n\n    def __init__(\n        self,\n        addresses: Optional[list[str]] = None,\n        authport: int = 1812,\n        acctport: int = 1813,\n        coaport: int = 3799,\n        hosts: Optional[dict] = None,\n        dict: Optional[Dictionary] = None,\n        auth_enabled: bool = True,\n        acct_enabled: bool = True,\n        coa_enabled: bool = False,\n    ):\n        \"\"\"Constructor.\n\n        :param     addresses: IP addresses to listen on\n        :type      addresses: sequence of strings\n        :param      authport: port to listen on for authentication packets\n        :type       authport: integer\n        :param      acctport: port to listen on for accounting packets\n        :type       acctport: integer\n        :param       coaport: port to listen on for CoA packets\n        :type        coaport: integer\n        :param         hosts: hosts who we can talk to\n        :type          hosts: dictionary mapping IP to RemoteHost class instances\n        :param          dict: RADIUS dictionary to use\n        :type           dict: Dictionary class instance\n        :param  auth_enabled: enable auth server (default True)\n        :type   auth_enabled: bool\n        :param  acct_enabled: enable accounting server (default True)\n        :type   acct_enabled: bool\n        :param   coa_enabled: enable coa server (default False)\n        :type    coa_enabled: bool\n        \"\"\"\n        super().__init__(authport, acctport, coaport, dict)\n\n        self.hosts = hosts or {}\n        self.auth_enabled = auth_enabled\n        self.authfds: list[socket.socket] = []\n        self.acct_enabled = acct_enabled\n        self.acctfds: list = []\n        self.coa_enabled = coa_enabled\n        self.coafds: list = []\n\n        if addresses:\n            for addr in addresses:\n                self.BindToAddress(addr)\n\n    def _GetAddrInfo(\n        self, addr: str\n    ) -&gt; set[tuple[socket.AddressFamily, str | int]] | list:\n        \"\"\"Use getaddrinfo to lookup all addresses for each address.\n\n        Returns a list of tuples or an empty list:\n          [(family, address)]\n\n        :param addr: IP address to lookup\n        :type  addr: string\n        \"\"\"\n        results = set()\n        try:\n            tmp = socket.getaddrinfo(addr, 80)\n        except socket.gaierror:\n            return []\n\n        for el in tmp:\n            results.add((el[0], el[4][0]))\n\n        return results\n\n    def BindToAddress(self, addr: str) -&gt; None:\n        \"\"\"Add an address to listen on a specific interface.\n        String \"0.0.0.0\" indicates you want to listen on all interfaces.\n\n        :param addr: IP address to listen on\n        :type  addr: string\n        \"\"\"\n        addrFamily = self._GetAddrInfo(addr)\n        for family, address in addrFamily:\n            if self.auth_enabled:\n                authfd = socket.socket(family, socket.SOCK_DGRAM)\n                authfd.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n                authfd.bind((address, self.authport))\n                self.authfds.append(authfd)\n\n            if self.acct_enabled:\n                acctfd = socket.socket(family, socket.SOCK_DGRAM)\n                acctfd.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n                acctfd.bind((address, self.acctport))\n                self.acctfds.append(acctfd)\n\n            if self.coa_enabled:\n                coafd = socket.socket(family, socket.SOCK_DGRAM)\n                coafd.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n                coafd.bind((address, self.coaport))\n                self.coafds.append(coafd)\n\n    def HandleAuthPacket(self, pkt: packet.Packet):\n        \"\"\"Authentication packet handler.\n        This is an empty function that is called when a valid\n        authentication packet has been received. It can be overriden in\n        derived classes to add custom behaviour.\n\n        :param pkt: packet to process\n        :type  pkt: Packet class instance\n        \"\"\"\n\n    def HandleAcctPacket(self, pkt: packet.Packet):\n        \"\"\"Accounting packet handler.\n        This is an empty function that is called when a valid\n        accounting packet has been received. It can be overriden in\n        derived classes to add custom behaviour.\n\n        :param pkt: packet to process\n        :type  pkt: Packet class instance\n        \"\"\"\n\n    def HandleCoaPacket(self, pkt: packet.Packet):\n        \"\"\"CoA packet handler.\n        This is an empty function that is called when a valid\n        accounting packet has been received. It can be overriden in\n        derived classes to add custom behaviour.\n\n        :param pkt: packet to process\n        :type  pkt: Packet class instance\n        \"\"\"\n\n    def HandleDisconnectPacket(self, pkt: packet.Packet):\n        \"\"\"CoA packet handler.\n        This is an empty function that is called when a valid\n        accounting packet has been received. It can be overriden in\n        derived classes to add custom behaviour.\n\n        :param pkt: packet to process\n        :type  pkt: Packet class instance\n        \"\"\"\n\n    def _AddSecret(self, pkt: packet.Packet) -&gt; None:\n        \"\"\"Add secret to packets received and raise ServerPacketError\n        for unknown hosts.\n\n        :param pkt: packet to process\n        :type  pkt: Packet class instance\n        \"\"\"\n        if pkt.source[0] in self.hosts:\n            pkt.secret = self.hosts[pkt.source[0]].secret\n        elif \"0.0.0.0\" in self.hosts:\n            pkt.secret = self.hosts[\"0.0.0.0\"].secret\n        else:\n            raise ServerPacketError(\"Received packet from unknown host\")\n\n    def _HandleAuthPacket(self, pkt: packet.Packet) -&gt; None:\n        \"\"\"Process a packet received on the authentication port.\n        If this packet should be dropped instead of processed a\n        ServerPacketError exception should be raised. The main loop will\n        drop the packet and log the reason.\n\n        :param pkt: packet to process\n        :type  pkt: Packet class instance\n        \"\"\"\n        self._AddSecret(pkt)\n        if pkt.code != packet.AccessRequest:\n            raise ServerPacketError(\n                \"Received non-authentication packet on authentication port\"\n            )\n        self.HandleAuthPacket(pkt)\n\n    def _HandleAcctPacket(self, pkt: packet.Packet) -&gt; None:\n        \"\"\"Process a packet received on the accounting port.\n        If this packet should be dropped instead of processed a\n        ServerPacketError exception should be raised. The main loop will\n        drop the packet and log the reason.\n\n        :param pkt: packet to process\n        :type  pkt: Packet class instance\n        \"\"\"\n        self._AddSecret(pkt)\n        if pkt.code not in [packet.AccountingRequest, packet.AccountingResponse]:\n            raise ServerPacketError(\"Received non-accounting packet on accounting port\")\n        self.HandleAcctPacket(pkt)\n\n    def _HandleCoaPacket(self, pkt: packet.Packet) -&gt; None:\n        \"\"\"Process a packet received on the coa port.\n        If this packet should be dropped instead of processed a\n        ServerPacketError exception should be raised. The main loop will\n        drop the packet and log the reason.\n\n        :param pkt: packet to process\n        :type  pkt: Packet class instance\n        \"\"\"\n        self._AddSecret(pkt)\n        if pkt.code == packet.CoARequest:\n            self.HandleCoaPacket(pkt)\n        elif pkt.code == packet.DisconnectRequest:\n            self.HandleDisconnectPacket(pkt)\n        else:\n            raise ServerPacketError(\"Received non-coa packet on coa port\")\n\n    def _GrabPacket(self, pktgen: Callable, fd: socket.socket) -&gt; packet.Packet:\n        \"\"\"Read a packet from a network connection.\n        This method assumes there is data waiting for to be read.\n\n        :param fd: socket to read packet from\n        :type  fd: socket class instance\n        :return: RADIUS packet\n        :rtype:  Packet class instance\n        \"\"\"\n        (data, source) = fd.recvfrom(self.MaxPacketSize)\n        pkt = pktgen(data)\n        pkt.source = source\n        pkt.fd = fd\n        return pkt\n\n    def _PrepareSockets(self) -&gt; None:\n        \"\"\"Prepare all sockets to receive packets.\"\"\"\n        for fd in self.authfds + self.acctfds + self.coafds:\n            self._fdmap[fd.fileno()] = fd\n            self._poll.register(\n                fd.fileno(), select.POLLIN | select.POLLPRI | select.POLLERR\n            )\n        if self.auth_enabled:\n            self._realauthfds = list(map(lambda x: x.fileno(), self.authfds))\n        if self.acct_enabled:\n            self._realacctfds = list(map(lambda x: x.fileno(), self.acctfds))\n        if self.coa_enabled:\n            self._realcoafds = list(map(lambda x: x.fileno(), self.coafds))\n\n    def CreateReplyPacket(self, pkt: packet.Packet, **attributes) -&gt; packet.Packet:\n        \"\"\"Create a reply packet.\n        Create a new packet which can be returned as a reply to a received\n        packet.\n\n        :param pkt:   original packet\n        :type pkt:    Packet instance\n        \"\"\"\n        reply = pkt.CreateReply(**attributes)\n        reply.source = pkt.source\n        return reply\n\n    def _ProcessInput(self, fd: socket.socket) -&gt; None:\n        \"\"\"Process available data.\n        If this packet should be dropped instead of processed a\n        PacketError exception should be raised. The main loop will\n        drop the packet and log the reason.\n\n        This function calls either HandleAuthPacket() or\n        HandleAcctPacket() depending on which socket is being\n        processed.\n\n        :param  fd: socket to read packet from\n        :type   fd: socket class instance\n        \"\"\"\n        if self.auth_enabled and fd.fileno() in self._realauthfds:\n            pkt = self._GrabPacket(\n                lambda data, s=self: s.CreateAuthPacket(packet=data), fd\n            )\n            self._HandleAuthPacket(pkt)\n        elif self.acct_enabled and fd.fileno() in self._realacctfds:\n            pkt = self._GrabPacket(\n                lambda data, s=self: s.CreateAcctPacket(packet=data), fd\n            )\n            self._HandleAcctPacket(pkt)\n        elif self.coa_enabled:\n            pkt = self._GrabPacket(\n                lambda data, s=self: s.CreateCoAPacket(packet=data), fd\n            )\n            self._HandleCoaPacket(pkt)\n        else:\n            raise ServerPacketError(\"Received packet for unknown handler\")\n\n    def Run(self) -&gt; None:\n        \"\"\"Main loop.\n        This method is the main loop for a RADIUS server. It waits\n        for packets to arrive via the network and calls other methods\n        to process them.\n        \"\"\"\n        self._poll = select.poll()\n        self._fdmap: dict[int, socket.socket] = {}\n        self._PrepareSockets()\n\n        while True:\n            for fd, event in self._poll.poll():\n                if event == select.POLLIN:\n                    try:\n                        fdo = self._fdmap[fd]\n                        self._ProcessInput(fdo)\n                    except ServerPacketError as err:\n                        logger.info(\"Dropping packet: \" + str(err))\n                    except packet.PacketError as err:\n                        logger.info(\"Received a broken packet: \" + str(err))\n                else:\n                    logger.error(\"Unexpected event in server main loop\")\n</code></pre>"},{"location":"api/server/#pyrad2.server.Server.BindToAddress","title":"<code>BindToAddress(addr)</code>","text":"<p>Add an address to listen on a specific interface. String \"0.0.0.0\" indicates you want to listen on all interfaces.</p> <p>:param addr: IP address to listen on :type  addr: string</p> Source code in <code>pyrad2/server.py</code> <pre><code>def BindToAddress(self, addr: str) -&gt; None:\n    \"\"\"Add an address to listen on a specific interface.\n    String \"0.0.0.0\" indicates you want to listen on all interfaces.\n\n    :param addr: IP address to listen on\n    :type  addr: string\n    \"\"\"\n    addrFamily = self._GetAddrInfo(addr)\n    for family, address in addrFamily:\n        if self.auth_enabled:\n            authfd = socket.socket(family, socket.SOCK_DGRAM)\n            authfd.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            authfd.bind((address, self.authport))\n            self.authfds.append(authfd)\n\n        if self.acct_enabled:\n            acctfd = socket.socket(family, socket.SOCK_DGRAM)\n            acctfd.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            acctfd.bind((address, self.acctport))\n            self.acctfds.append(acctfd)\n\n        if self.coa_enabled:\n            coafd = socket.socket(family, socket.SOCK_DGRAM)\n            coafd.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            coafd.bind((address, self.coaport))\n            self.coafds.append(coafd)\n</code></pre>"},{"location":"api/server/#pyrad2.server.Server.CreateReplyPacket","title":"<code>CreateReplyPacket(pkt, **attributes)</code>","text":"<p>Create a reply packet. Create a new packet which can be returned as a reply to a received packet.</p> <p>:param pkt:   original packet :type pkt:    Packet instance</p> Source code in <code>pyrad2/server.py</code> <pre><code>def CreateReplyPacket(self, pkt: packet.Packet, **attributes) -&gt; packet.Packet:\n    \"\"\"Create a reply packet.\n    Create a new packet which can be returned as a reply to a received\n    packet.\n\n    :param pkt:   original packet\n    :type pkt:    Packet instance\n    \"\"\"\n    reply = pkt.CreateReply(**attributes)\n    reply.source = pkt.source\n    return reply\n</code></pre>"},{"location":"api/server/#pyrad2.server.Server.HandleAcctPacket","title":"<code>HandleAcctPacket(pkt)</code>","text":"<p>Accounting packet handler. This is an empty function that is called when a valid accounting packet has been received. It can be overriden in derived classes to add custom behaviour.</p> <p>:param pkt: packet to process :type  pkt: Packet class instance</p> Source code in <code>pyrad2/server.py</code> <pre><code>def HandleAcctPacket(self, pkt: packet.Packet):\n    \"\"\"Accounting packet handler.\n    This is an empty function that is called when a valid\n    accounting packet has been received. It can be overriden in\n    derived classes to add custom behaviour.\n\n    :param pkt: packet to process\n    :type  pkt: Packet class instance\n    \"\"\"\n</code></pre>"},{"location":"api/server/#pyrad2.server.Server.HandleAuthPacket","title":"<code>HandleAuthPacket(pkt)</code>","text":"<p>Authentication packet handler. This is an empty function that is called when a valid authentication packet has been received. It can be overriden in derived classes to add custom behaviour.</p> <p>:param pkt: packet to process :type  pkt: Packet class instance</p> Source code in <code>pyrad2/server.py</code> <pre><code>def HandleAuthPacket(self, pkt: packet.Packet):\n    \"\"\"Authentication packet handler.\n    This is an empty function that is called when a valid\n    authentication packet has been received. It can be overriden in\n    derived classes to add custom behaviour.\n\n    :param pkt: packet to process\n    :type  pkt: Packet class instance\n    \"\"\"\n</code></pre>"},{"location":"api/server/#pyrad2.server.Server.HandleCoaPacket","title":"<code>HandleCoaPacket(pkt)</code>","text":"<p>CoA packet handler. This is an empty function that is called when a valid accounting packet has been received. It can be overriden in derived classes to add custom behaviour.</p> <p>:param pkt: packet to process :type  pkt: Packet class instance</p> Source code in <code>pyrad2/server.py</code> <pre><code>def HandleCoaPacket(self, pkt: packet.Packet):\n    \"\"\"CoA packet handler.\n    This is an empty function that is called when a valid\n    accounting packet has been received. It can be overriden in\n    derived classes to add custom behaviour.\n\n    :param pkt: packet to process\n    :type  pkt: Packet class instance\n    \"\"\"\n</code></pre>"},{"location":"api/server/#pyrad2.server.Server.HandleDisconnectPacket","title":"<code>HandleDisconnectPacket(pkt)</code>","text":"<p>CoA packet handler. This is an empty function that is called when a valid accounting packet has been received. It can be overriden in derived classes to add custom behaviour.</p> <p>:param pkt: packet to process :type  pkt: Packet class instance</p> Source code in <code>pyrad2/server.py</code> <pre><code>def HandleDisconnectPacket(self, pkt: packet.Packet):\n    \"\"\"CoA packet handler.\n    This is an empty function that is called when a valid\n    accounting packet has been received. It can be overriden in\n    derived classes to add custom behaviour.\n\n    :param pkt: packet to process\n    :type  pkt: Packet class instance\n    \"\"\"\n</code></pre>"},{"location":"api/server/#pyrad2.server.Server.Run","title":"<code>Run()</code>","text":"<p>Main loop. This method is the main loop for a RADIUS server. It waits for packets to arrive via the network and calls other methods to process them.</p> Source code in <code>pyrad2/server.py</code> <pre><code>def Run(self) -&gt; None:\n    \"\"\"Main loop.\n    This method is the main loop for a RADIUS server. It waits\n    for packets to arrive via the network and calls other methods\n    to process them.\n    \"\"\"\n    self._poll = select.poll()\n    self._fdmap: dict[int, socket.socket] = {}\n    self._PrepareSockets()\n\n    while True:\n        for fd, event in self._poll.poll():\n            if event == select.POLLIN:\n                try:\n                    fdo = self._fdmap[fd]\n                    self._ProcessInput(fdo)\n                except ServerPacketError as err:\n                    logger.info(\"Dropping packet: \" + str(err))\n                except packet.PacketError as err:\n                    logger.info(\"Received a broken packet: \" + str(err))\n            else:\n                logger.error(\"Unexpected event in server main loop\")\n</code></pre>"},{"location":"api/server/#pyrad2.server.Server.__init__","title":"<code>__init__(addresses=None, authport=1812, acctport=1813, coaport=3799, hosts=None, dict=None, auth_enabled=True, acct_enabled=True, coa_enabled=False)</code>","text":"<p>Constructor.</p> <p>:param     addresses: IP addresses to listen on :type      addresses: sequence of strings :param      authport: port to listen on for authentication packets :type       authport: integer :param      acctport: port to listen on for accounting packets :type       acctport: integer :param       coaport: port to listen on for CoA packets :type        coaport: integer :param         hosts: hosts who we can talk to :type          hosts: dictionary mapping IP to RemoteHost class instances :param          dict: RADIUS dictionary to use :type           dict: Dictionary class instance :param  auth_enabled: enable auth server (default True) :type   auth_enabled: bool :param  acct_enabled: enable accounting server (default True) :type   acct_enabled: bool :param   coa_enabled: enable coa server (default False) :type    coa_enabled: bool</p> Source code in <code>pyrad2/server.py</code> <pre><code>def __init__(\n    self,\n    addresses: Optional[list[str]] = None,\n    authport: int = 1812,\n    acctport: int = 1813,\n    coaport: int = 3799,\n    hosts: Optional[dict] = None,\n    dict: Optional[Dictionary] = None,\n    auth_enabled: bool = True,\n    acct_enabled: bool = True,\n    coa_enabled: bool = False,\n):\n    \"\"\"Constructor.\n\n    :param     addresses: IP addresses to listen on\n    :type      addresses: sequence of strings\n    :param      authport: port to listen on for authentication packets\n    :type       authport: integer\n    :param      acctport: port to listen on for accounting packets\n    :type       acctport: integer\n    :param       coaport: port to listen on for CoA packets\n    :type        coaport: integer\n    :param         hosts: hosts who we can talk to\n    :type          hosts: dictionary mapping IP to RemoteHost class instances\n    :param          dict: RADIUS dictionary to use\n    :type           dict: Dictionary class instance\n    :param  auth_enabled: enable auth server (default True)\n    :type   auth_enabled: bool\n    :param  acct_enabled: enable accounting server (default True)\n    :type   acct_enabled: bool\n    :param   coa_enabled: enable coa server (default False)\n    :type    coa_enabled: bool\n    \"\"\"\n    super().__init__(authport, acctport, coaport, dict)\n\n    self.hosts = hosts or {}\n    self.auth_enabled = auth_enabled\n    self.authfds: list[socket.socket] = []\n    self.acct_enabled = acct_enabled\n    self.acctfds: list = []\n    self.coa_enabled = coa_enabled\n    self.coafds: list = []\n\n    if addresses:\n        for addr in addresses:\n            self.BindToAddress(addr)\n</code></pre>"},{"location":"api/server/#pyrad2.server.ServerPacketError","title":"<code>ServerPacketError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception class for bogus packets. ServerPacketError exceptions are only used inside the Server class to abort processing of a packet.</p> Source code in <code>pyrad2/server.py</code> <pre><code>class ServerPacketError(Exception):\n    \"\"\"Exception class for bogus packets.\n    ServerPacketError exceptions are only used inside the Server class to\n    abort processing of a packet.\n    \"\"\"\n</code></pre>"},{"location":"api/server_async/","title":"Server Async","text":""},{"location":"api/tools/","title":"tools","text":""},{"location":"api/tools/#pyrad2.tools.DecodeAddress","title":"<code>DecodeAddress(addr)</code>","text":"<p>Decode 4-byte data into an IPv4 dotted string.</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def DecodeAddress(addr: Buffer) -&gt; str:\n    \"\"\"Decode 4-byte data into an IPv4 dotted string.\"\"\"\n    return \".\".join(map(str, struct.unpack(\"BBBB\", addr)))\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.DecodeAscendBinary","title":"<code>DecodeAscendBinary(orig_bytes)</code>","text":"<p>Decode Ascend-specific binary format (length-prefixed).</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def DecodeAscendBinary(orig_bytes: bytes) -&gt; bytes:\n    \"\"\"Decode Ascend-specific binary format (length-prefixed).\"\"\"\n    return orig_bytes\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.DecodeAttr","title":"<code>DecodeAttr(datatype, value)</code>","text":"<p>Decode a RADIUS attribute from bytes into a type and value.</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def DecodeAttr(datatype: str, value) -&gt; bytes | str:\n    \"\"\"Decode a RADIUS attribute from bytes into a type and value.\"\"\"\n    if datatype == \"string\":\n        return DecodeString(value)\n    elif datatype == \"octets\":\n        return DecodeOctets(value)\n    elif datatype == \"integer\":\n        return DecodeInteger(value)\n    elif datatype == \"ipaddr\":\n        return DecodeAddress(value)\n    elif datatype == \"ipv6prefix\":\n        return DecodeIPv6Prefix(value)\n    elif datatype == \"ipv6addr\":\n        return DecodeIPv6Address(value)\n    elif datatype == \"abinary\":\n        return DecodeAscendBinary(value)\n    elif datatype == \"signed\":\n        return DecodeInteger(value, \"!i\")\n    elif datatype == \"short\":\n        return DecodeInteger(value, \"!H\")\n    elif datatype == \"byte\":\n        return DecodeInteger(value, \"!B\")\n    elif datatype == \"date\":\n        return DecodeDate(value)\n    elif datatype == \"integer64\":\n        return DecodeInteger64(value)\n    else:\n        raise ValueError(\"Unknown attribute type %s\" % datatype)\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.DecodeDate","title":"<code>DecodeDate(num)</code>","text":"<p>Decode 4-byte UNIX timestamp into an integer.</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def DecodeDate(num: Buffer) -&gt; bytes:\n    \"\"\"Decode 4-byte UNIX timestamp into an integer.\"\"\"\n    return (struct.unpack(\"!I\", num))[0]\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.DecodeIPv6Address","title":"<code>DecodeIPv6Address(addr)</code>","text":"<p>Decode 16-byte IPv6 address into a readable string.</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def DecodeIPv6Address(addr: bytes | bytearray) -&gt; str:\n    \"\"\"Decode 16-byte IPv6 address into a readable string.\"\"\"\n    addr = addr + b\"\\x00\" * (16 - len(addr))\n    prefix = \":\".join(map(\"{:x}\".format, struct.unpack(\"!\" + \"H\" * 8, addr)))\n    return str(IPv6Address(prefix))\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.DecodeIPv6Prefix","title":"<code>DecodeIPv6Prefix(addr)</code>","text":"<p>Decode 18-byte IPv6 prefix format into address/prefix tuple.</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def DecodeIPv6Prefix(addr: bytes | bytearray) -&gt; str:\n    \"\"\"Decode 18-byte IPv6 prefix format into address/prefix tuple.\"\"\"\n    addr = addr + b\"\\x00\" * (18 - len(addr))\n    _, length, prefix = \":\".join(\n        map(\"{:x}\".format, struct.unpack(\"!BB\" + \"H\" * 8, addr))\n    ).split(\":\", 2)\n    return str(IPv6Network(\"{}/{}\".format(prefix, int(length, 16))))\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.DecodeInteger","title":"<code>DecodeInteger(num, format='!I')</code>","text":"<p>Decode 4-byte big-endian unsigned integer.</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def DecodeInteger(num: Buffer, format: str = \"!I\") -&gt; bytes:\n    \"\"\"Decode 4-byte big-endian unsigned integer.\"\"\"\n    return (struct.unpack(format, num))[0]\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.DecodeInteger64","title":"<code>DecodeInteger64(num, format='!Q')</code>","text":"<p>Decode 8-byte big-endian unsigned integer.</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def DecodeInteger64(num: Buffer, format: str = \"!Q\") -&gt; bytes:\n    \"\"\"Decode 8-byte big-endian unsigned integer.\"\"\"\n    return (struct.unpack(format, num))[0]\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.DecodeOctets","title":"<code>DecodeOctets(orig_bytes)</code>","text":"<p>Return bytes unchanged (octet format).</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def DecodeOctets(orig_bytes: bytes) -&gt; bytes:\n    \"\"\"Return bytes unchanged (octet format).\"\"\"\n    return orig_bytes\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.DecodeString","title":"<code>DecodeString(orig_str)</code>","text":"<p>Decode UTF-8 bytes into a string.</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def DecodeString(orig_str: bytes) -&gt; str:\n    \"\"\"Decode UTF-8 bytes into a string.\"\"\"\n    return orig_str.decode(\"utf-8\")\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.EncodeAddress","title":"<code>EncodeAddress(addr)</code>","text":"<p>Encode an IPv4 address (dotted string) to 4-byte format.</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def EncodeAddress(addr: str) -&gt; bytes:\n    \"\"\"Encode an IPv4 address (dotted string) to 4-byte format.\"\"\"\n    if not isinstance(addr, str):\n        raise TypeError(\"Address has to be a string\")\n    return IPv4Address(addr).packed\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.EncodeAscendBinary","title":"<code>EncodeAscendBinary(orig_str)</code>","text":"<p>Encode binary data in Ascend-specific format (length prefixed).</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def EncodeAscendBinary(orig_str: str) -&gt; bytes:\n    \"\"\"Encode binary data in Ascend-specific format (length prefixed).\"\"\"\n    \"\"\"\n    Format: List of type=value pairs separated by spaces.\n\n    Example: 'family=ipv4 action=discard direction=in dst=10.10.255.254/32'\n\n    Note: redirect(0x20) action is added for http-redirect (walled garden) use case\n\n    Type:\n        family      ipv4(default) or ipv6\n        action      discard(default) or accept or redirect\n        direction   in(default) or out\n        src         source prefix (default ignore)\n        dst         destination prefix (default ignore)\n        proto       protocol number / next-header number (default ignore)\n        sport       source port (default ignore)\n        dport       destination port (default ignore)\n        sportq      source port qualifier (default 0)\n        dportq      destination port qualifier (default 0)\n\n    Source/Destination Port Qualifier:\n        0   no compare\n        1   less than\n        2   equal to\n        3   greater than\n        4   not equal to\n    \"\"\"\n\n    terms = {\n        \"family\": b\"\\x01\",\n        \"action\": b\"\\x00\",\n        \"direction\": b\"\\x01\",\n        \"src\": b\"\\x00\\x00\\x00\\x00\",\n        \"dst\": b\"\\x00\\x00\\x00\\x00\",\n        \"srcl\": b\"\\x00\",\n        \"dstl\": b\"\\x00\",\n        \"proto\": b\"\\x00\",\n        \"sport\": b\"\\x00\\x00\",\n        \"dport\": b\"\\x00\\x00\",\n        \"sportq\": b\"\\x00\",\n        \"dportq\": b\"\\x00\",\n    }\n\n    family = \"ipv4\"\n    ip: IPv4Network | IPv6Network\n\n    for t in orig_str.split(\" \"):\n        key, value = t.split(\"=\")\n        if key == \"family\" and value == \"ipv6\":\n            family = \"ipv6\"\n            terms[key] = b\"\\x03\"\n            if terms[\"src\"] == b\"\\x00\\x00\\x00\\x00\":\n                terms[\"src\"] = 16 * b\"\\x00\"\n            if terms[\"dst\"] == b\"\\x00\\x00\\x00\\x00\":\n                terms[\"dst\"] = 16 * b\"\\x00\"\n        elif key == \"action\" and value == \"accept\":\n            terms[key] = b\"\\x01\"\n        elif key == \"action\" and value == \"redirect\":\n            terms[key] = b\"\\x20\"\n        elif key == \"direction\" and value == \"out\":\n            terms[key] = b\"\\x00\"\n        elif key == \"src\" or key == \"dst\":\n            if family == \"ipv4\":\n                ip = IPv4Network(value)\n            else:\n                ip = IPv6Network(value)\n            terms[key] = ip.network_address.packed\n            terms[key + \"l\"] = struct.pack(\"B\", ip.prefixlen)\n        elif key == \"sport\" or key == \"dport\":\n            terms[key] = struct.pack(\"!H\", int(value))\n        elif key == \"sportq\" or key == \"dportq\" or key == \"proto\":\n            terms[key] = struct.pack(\"B\", int(value))\n\n    trailer = 8 * b\"\\x00\"\n\n    result = b\"\".join(\n        (\n            terms[\"family\"],\n            terms[\"action\"],\n            terms[\"direction\"],\n            b\"\\x00\",\n            terms[\"src\"],\n            terms[\"dst\"],\n            terms[\"srcl\"],\n            terms[\"dstl\"],\n            terms[\"proto\"],\n            b\"\\x00\",\n            terms[\"sport\"],\n            terms[\"dport\"],\n            terms[\"sportq\"],\n            terms[\"dportq\"],\n            b\"\\x00\\x00\",\n            trailer,\n        )\n    )\n    return result\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.EncodeAttr","title":"<code>EncodeAttr(datatype, value)</code>","text":"<p>Encode a RADIUS attribute (type, value, length) into bytes.</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def EncodeAttr(datatype: str, value) -&gt; bytes | str:\n    \"\"\"Encode a RADIUS attribute (type, value, length) into bytes.\"\"\"\n    if datatype == \"string\":\n        return EncodeString(value)\n    elif datatype == \"octets\":\n        return EncodeOctets(value)\n    elif datatype == \"integer\":\n        return EncodeInteger(value)\n    elif datatype == \"ipaddr\":\n        return EncodeAddress(value)\n    elif datatype == \"ipv6prefix\":\n        return EncodeIPv6Prefix(value)\n    elif datatype == \"ipv6addr\":\n        return EncodeIPv6Address(value)\n    elif datatype == \"abinary\":\n        return EncodeAscendBinary(value)\n    elif datatype == \"signed\":\n        return EncodeInteger(value, \"!i\")\n    elif datatype == \"short\":\n        return EncodeInteger(value, \"!H\")\n    elif datatype == \"byte\":\n        return EncodeInteger(value, \"!B\")\n    elif datatype == \"date\":\n        return EncodeDate(value)\n    elif datatype == \"integer64\":\n        return EncodeInteger64(value)\n    else:\n        raise ValueError(\"Unknown attribute type %s\" % datatype)\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.EncodeDate","title":"<code>EncodeDate(num)</code>","text":"<p>Encode a UNIX timestamp (int) to 4-byte format.</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def EncodeDate(num: int) -&gt; bytes:\n    \"\"\"Encode a UNIX timestamp (int) to 4-byte format.\"\"\"\n    if not isinstance(num, int):\n        raise TypeError(\"Can not encode non-integer as date\")\n    return struct.pack(\"!I\", num)\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.EncodeIPv6Address","title":"<code>EncodeIPv6Address(addr)</code>","text":"<p>Encode an IPv6 address (as string) to 16-byte format.</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def EncodeIPv6Address(addr: str) -&gt; bytes:\n    \"\"\"Encode an IPv6 address (as string) to 16-byte format.\"\"\"\n    if not isinstance(addr, str):\n        raise TypeError(\"IPv6 Address has to be a string\")\n    return IPv6Address(addr).packed\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.EncodeIPv6Prefix","title":"<code>EncodeIPv6Prefix(addr)</code>","text":"<p>Encode an IPv6 address and prefix length to 18-byte format.</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def EncodeIPv6Prefix(addr: str) -&gt; bytes:\n    \"\"\"Encode an IPv6 address and prefix length to 18-byte format.\"\"\"\n    if not isinstance(addr, str):\n        raise TypeError(\"IPv6 Prefix has to be a string\")\n    ip = IPv6Network(addr, strict=False)\n    return struct.pack(\"2B\", *[0, ip.prefixlen]) + ip.network_address.packed\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.EncodeInteger","title":"<code>EncodeInteger(num, format='!I')</code>","text":"<p>Encode a 32-bit unsigned integer to 4-byte big-endian.</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def EncodeInteger(num: int, format: str = \"!I\") -&gt; bytes:\n    \"\"\"Encode a 32-bit unsigned integer to 4-byte big-endian.\"\"\"\n    try:\n        num = int(num)\n    except (ValueError, TypeError):\n        raise TypeError(\"Can not encode non-integer as integer\")\n    return struct.pack(format, num)\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.EncodeInteger64","title":"<code>EncodeInteger64(num, format='!Q')</code>","text":"<p>Encode a 64-bit unsigned integer to 8-byte big-endian.</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def EncodeInteger64(num: int, format: str = \"!Q\") -&gt; bytes:\n    \"\"\"Encode a 64-bit unsigned integer to 8-byte big-endian.\"\"\"\n    try:\n        num = int(num)\n    except (ValueError, TypeError):\n        raise TypeError(\"Can not encode non-integer as integer64\")\n    return struct.pack(format, num)\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.EncodeOctets","title":"<code>EncodeOctets(octetstring)</code>","text":"<p>Encode raw octet string (already in bytes).</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def EncodeOctets(octetstring: str) -&gt; str | bytes:\n    \"\"\"Encode raw octet string (already in bytes).\"\"\"\n    # Check for max length of the hex encoded with 0x prefix, as a sanity check\n    if len(octetstring) &gt; 508:\n        raise ValueError(\"Can only encode strings of &lt;= 253 characters\")\n\n    hexstring: str | bytes\n    encoded_octets: str | bytes\n    if isinstance(octetstring, bytes) and octetstring.startswith(b\"0x\"):\n        hexstring = octetstring.split(b\"0x\")[1]\n        encoded_octets = binascii.unhexlify(hexstring)\n    elif isinstance(octetstring, str) and octetstring.startswith(\"0x\"):\n        hexstring = octetstring.split(\"0x\")[1]\n        encoded_octets = binascii.unhexlify(hexstring)\n    elif isinstance(octetstring, str) and octetstring.isdecimal():\n        encoded_octets = struct.pack(\"&gt;L\", int(octetstring)).lstrip(b\"\\x00\")\n    else:\n        encoded_octets = octetstring\n\n    # Check for the encoded value being longer than 253 chars\n    if len(encoded_octets) &gt; 253:\n        raise ValueError(\"Can only encode strings of &lt;= 253 characters\")\n\n    return encoded_octets\n</code></pre>"},{"location":"api/tools/#pyrad2.tools.EncodeString","title":"<code>EncodeString(origstr)</code>","text":"<p>Encode a string to bytes, ensuring it is UTF-8 encoded.</p> Source code in <code>pyrad2/tools.py</code> <pre><code>def EncodeString(origstr: str) -&gt; bytes:\n    \"\"\"Encode a string to bytes, ensuring it is UTF-8 encoded.\"\"\"\n    if len(origstr) &gt; 253:\n        raise ValueError(\"Can only encode strings of &lt;= 253 characters\")\n    if isinstance(origstr, str):\n        return origstr.encode(\"utf-8\")\n    else:\n        return origstr\n</code></pre>"}]}