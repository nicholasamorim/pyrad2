{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyrad2","text":"<p>pyrad2 is an implementation of a RADIUS client/server as described in RFC2865. It takes care of all the details like building RADIUS packets, sending them and decoding responses.</p> <p>See the Getting Started guide for a tutorial on how to get started.</p>"},{"location":"api/","title":"API Reference","text":"<p>At the moment, please check the code here.</p>"},{"location":"compatibility/","title":"Pyrad Compatibility","text":"<p>In so far, there is full compatibility with pyrad and you can just replace your imports with <code>pyrad2</code>.</p>"},{"location":"getting_started/","title":"Getting started","text":"<p>Note</p> <p>This guide is a work in progress.</p> <ul> <li>How does pyrad2 work<ul> <li>RADIUS Concepts<ul> <li>Dictionary</li> </ul> </li> </ul> </li> <li>RADIUS Server<ul> <li>Handling packets</li> <li>Replying</li> </ul> </li> <li>Running a client<ul> <li>Sending an authentication packet</li> </ul> </li> <li>Setting attributes</li> </ul> Install with pip<pre><code>$ pip install pyrad2\n</code></pre> Install with uv<pre><code>$ uv add pyrad2\n</code></pre>"},{"location":"getting_started/#how-does-pyrad2-work","title":"How does pyrad2 work","text":"<p>pyrad2 allows you to build servers and clients for the RADIUS protocol.</p> <p>It is not meant to be a standalone implementation like FreeRADIUS, but rather as a tool to allow you to build your own server and client.</p>"},{"location":"getting_started/#radius-concepts","title":"RADIUS Concepts","text":""},{"location":"getting_started/#dictionary","title":"Dictionary","text":"<p>For the purpose of using pyrad2, the most important concept is the Dictionary. The dictionary is an actual file on the filesystem.</p> <p>Note</p> <p>Dictionary files are textfiles with one command per line.</p> <p>RADIUS uses dictionaries to define the attributes that can be used in packets. The Dictionary class stores the attribute definitions from one or more dictionary files and allows Server/Client to understand what an attribute code means.</p> <p>Here's an example of how it looks:</p> <pre><code>ATTRIBUTE   User-Name           1   string\nATTRIBUTE   User-Password       2   string\nATTRIBUTE   CHAP-Password       3   octets\n</code></pre> <p>You can find a reference dictionary file here. Another dictionary is provided here with FreeRADIUS vendor-specific attributes.</p> <p>For our example, download both files and place it into your project folder.</p> <p>When you see code like this:</p> Loading a dictionary<pre><code>dictfile = dictionary.Dictionary(\"dictionary\")\n</code></pre> <p>You are actually passing a path to a file (or a file-like object) called <code>dictionary</code>, so make sure the file you pass is accessible from your code and it's a valid dictionary file.</p>"},{"location":"getting_started/#radius-server","title":"RADIUS Server","text":"<p>There are two ways of running a server: sync or async. </p> <p>Pick an implementation above and copy the code into your project. This should just work now if you have already installed <code>pyrad2</code>:</p> Running the example server<pre><code>uv run server_async.py\n</code></pre> <p>You should see the logs:</p> <pre><code>2025-07-07 12:38:19.929 | INFO | pyrad2.server_async:connection_made:57 - [127.0.0.1:1812] Transport created\n2025-07-07 12:38:19.929 | INFO | pyrad2.server_async:connection_made:57 - [127.0.0.1:1813] Transport created\n2025-07-07 12:38:19.929 | INFO | pyrad2.server_async:connection_made:57 - [127.0.0.1:3799] Transport created\n</code></pre> <p>Warning</p> <p>Sync support may be dropped in the future. We strongly recommend you use the async version.</p>"},{"location":"getting_started/#handling-packets","title":"Handling packets","text":"<p>Note</p> <p>You may want to jump ahead to the client section in order to make a test request to your server.</p> <p>Fundamentally, you have to subclass the <code>pyrad2</code> server and implement four methods.</p> Methods you have to implement<pre><code>class MyRadiusServer(ServerAsync):\n    def handle_auth_packet(self, protocol, pkt, addr):\n\n    def handle_acct_packet(self, protocol, pkt, addr):\n\n    def handle_coa_packet(self, protocol:, pkt, addr):\n\n    def handle_disconnect_packet(self, protocol, pkt, addr):\n</code></pre> <p>When a packet arrives at these functions it has already been parsed, validated and instantiated into a pyrad2.packet.Packet class.</p> <p>The example implementation provided simply logs details of the request it has just received and it's meant to illustrate the contents of the packet being received.</p> <pre><code>def handle_auth_packet(self, protocol, pkt, addr):\n    logger.info(\"Received an authentication request with id {}\", pkt.id)\n    logger.info(\"Authenticator {}\", pkt.authenticator.hex())\n    logger.info(\"Secret {}\", pkt.secret)\n    logger.info(\"Attributes: \")\n    for attr in pkt.keys():\n        logger.info(\"{}: {}\", attr, pkt[attr])\n</code></pre>"},{"location":"getting_started/#replying","title":"Replying","text":"<p>To reply a packet, you must create a reply packet using <code>self.create_reply_packet</code>. The first argument is the packet you received and you can pass keyword arguments to populate the reply packet.</p> Replying<pre><code>def handle_auth_packet(self, protocol, pkt, addr):\n    ...\n    reply = self.create_reply_packet(\n        pkt,\n        **{\n            \"Service-Type\": \"Framed-User\",\n            \"Framed-IP-Address\": \"192.168.0.1\",\n            \"Framed-IPv6-Prefix\": \"fc66::1/64\",\n        },\n    )\n\n    reply.code = AccessAccept\n    protocol.send_response(reply, addr)\n</code></pre> <p>Lastly, you set the reply code. Possible reply codes can be imported from <code>pyrad2.packet</code>.</p> Reply constants in pyrad2.packet<pre><code>AccessAccept = 2\nAccessReject = 3\nAccountingResponse = 5\nStatusServer = 12\nStatusClient = 13\nDisconnectACK = 41\nDisconnectNAK = 42\nCoAACK = 44\nCoANAK = 45\n</code></pre>"},{"location":"getting_started/#running-a-client","title":"Running a client","text":"<p>To instantiate a client you can use <code>ClientAsync</code>. A sync version is also provided in <code>pyrad2.client</code>.</p> <p>Note</p> <p>Both your server and client must be loaded with the same dictionary. Remember, this is how the client and server can understand what it means to use a given attribute code.</p> Instantiating a client<pre><code>from pyrad2.client_async import ClientAsync\nfrom pyrad2.dictionary import Dictionary\n\n\nclient = ClientAsync(\n    server=\"localhost\",\n    secret=b\"Kah3choteereethiejeimaeziecumi\",\n    timeout=4,\n    dict=Dictionary(\"dictionary\"),\n)\n</code></pre> <p>Note</p> <p>In real code, we would never pass the secret hardcoded.</p>"},{"location":"getting_started/#sending-an-authentication-packet","title":"Sending an authentication packet","text":"<p>You can find the example for an auth request here.</p> Making an authentication request<pre><code>$ uv run auth_async.py  # make sure the server is running before\n\n2025-07-07 13:06:36.984 | INFO     | pyrad2.client_async:connection_made:112 - [localhost:3799] Transport created with binding in ::1:62525\n2025-07-07 13:06:36.984 | INFO     | pyrad2.client_async:connection_made:112 - [localhost:1812] Transport created with binding in 127.0.0.1:8000\n2025-07-07 13:06:36.984 | INFO     | pyrad2.client_async:connection_made:112 - [localhost:1813] Transport created with binding in ::1:64970\n2025-07-07 13:06:36.989 | INFO     | __main__:test_auth1:87 - Access accepted\n2025-07-07 13:06:36.989 | INFO     | __main__:test_auth1:91 - Attributes returned by server:\n2025-07-07 13:06:36.989 | INFO     | __main__:test_auth1:93 - Service-Type: ['Framed-User']\n2025-07-07 13:06:36.989 | INFO     | __main__:test_auth1:93 - Framed-IP-Address: ['192.168.0.1']\n2025-07-07 13:06:36.989 | INFO     | __main__:test_auth1:93 - Framed-IPv6-Prefix: ['fc66::/64']\n</code></pre> <p>This is the core code that creates the packet.  </p> <pre><code>def create_request(client, user):\n    req = client.CreateAuthPacket(User_Name=user)\n\n    req[\"NAS-IP-Address\"] = \"192.168.1.10\"\n    req[\"NAS-Port\"] = 0\n    req[\"Service-Type\"] = \"Login-User\"\n    req[\"NAS-Identifier\"] = \"trillian\"\n    req[\"Called-Station-Id\"] = \"00-04-5F-00-0F-D1\"\n    req[\"Calling-Station-Id\"] = \"00-01-24-80-B3-9C\"\n    req[\"Framed-IP-Address\"] = \"10.0.0.100\"\n\n    return req\n</code></pre> <p>You can find a list of standard RADIUS attributes here. Note that these do not include vendor-specific attributes.</p>"},{"location":"getting_started/#setting-attributes","title":"Setting attributes","text":"<p>To set attributes in the <code>Client</code> object, you need to replace underscores with hyphens. So instead of <code>User_Name</code>, you use <code>User-Name</code>. The former is used in python code and the latter is used directly in the underlying data.</p> Naming inconsistencies<pre><code>req = srv.CreateAuthPacket(User_Name=\"wichert\")\n\n# But if acessing the attributes directly\nreq[\"User-Name\"] = \"wichert2\"\nreq[\"NAS-IP-Address\"] = \"192.168.1.10\"\n</code></pre> <p>[Suggestion]: Add some description for the valid arguments that could be passed to CreateAuthPacket.</p>"}]}